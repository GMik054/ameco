var LWC = (function (exports) {
  'use strict';

  function _arrayLikeToArray(arr, len1) {
      if (len1 == null || len1 > arr.length) len1 = arr.length;
      for(var i1 = 0, arr2 = new Array(len1); i1 < len1; i1++)arr2[i1] = arr[i1];
      return arr2;
  }
  function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
  }
  function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _assertThisInitialized(self) {
      if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
  }
  function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
      }
  }
  function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
          return true;
      } catch (e) {
          return false;
      }
  }
  function _construct(Parent1, args1, Class1) {
      if (isNativeReflectConstruct()) {
          _construct = Reflect.construct;
      } else {
          _construct = function _construct(Parent, args, Class) {
              var a = [
                  null
              ];
              a.push.apply(a, args);
              var Constructor = Function.bind.apply(Parent, a);
              var instance = new Constructor();
              if (Class) _setPrototypeOf(instance, Class.prototype);
              return instance;
          };
      }
      return _construct.apply(null, arguments);
  }
  function _defineProperties(target, props) {
      for(var i2 = 0; i2 < props.length; i2++){
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
      }
  }
  function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
  }
  function _defineProperty(obj, key, value) {
      if (key in obj) {
          Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
          });
      } else {
          obj[key] = value;
      }
      return obj;
  }
  function _get(target1, property1, receiver1) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
          _get = Reflect.get;
      } else {
          _get = function _get(target, property, receiver) {
              var base = _superPropBase(target, property);
              if (!base) return;
              var desc = Object.getOwnPropertyDescriptor(base, property);
              if (desc.get) {
                  return desc.get.call(receiver);
              }
              return desc.value;
          };
      }
      return _get(target1, property1, receiver1 || target1);
  }
  function _getPrototypeOf(o1) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o1);
  }
  function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
              value: subClass,
              writable: true,
              configurable: true
          }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _instanceof(left, right) {
      if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
          return !!right[Symbol.hasInstance](left);
      } else {
          return left instanceof right;
      }
  }
  function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _iterableToArrayLimit(arr, i3) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
          for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
              _arr.push(_s.value);
              if (i3 && _arr.length === i3) break;
          }
      } catch (err) {
          _d = true;
          _e = err;
      } finally{
          try {
              if (!_n && _i["return"] != null) _i["return"]();
          } finally{
              if (_d) throw _e;
          }
      }
      return _arr;
  }
  function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
      }
      return _assertThisInitialized(self);
  }
  function _setPrototypeOf(o2, p1) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
      };
      return _setPrototypeOf(o2, p1);
  }
  function _slicedToArray(arr, i4) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i4) || _unsupportedIterableToArray(arr, i4) || _nonIterableRest();
  }
  function _superPropBase(object, property) {
      while(!Object.prototype.hasOwnProperty.call(object, property)){
          object = _getPrototypeOf(object);
          if (object === null) break;
      }
      return object;
  }
  function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  var _typeof = function(obj) {
      "@swc/helpers - typeof";
      return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };
  function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(n);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _wrapNativeSuper(Class2) {
      var _cache = typeof Map === "function" ? new Map() : undefined;
      _wrapNativeSuper = function _wrapNativeSuper(Class) {
          if (Class === null || !_isNativeFunction(Class)) return Class;
          if (typeof Class !== "function") {
              throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
              if (_cache.has(Class)) return _cache.get(Class);
              _cache.set(Class, Wrapper);
          }
          function Wrapper() {
              return _construct(Class, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class.prototype, {
              constructor: {
                  value: Wrapper,
                  enumerable: false,
                  writable: true,
                  configurable: true
              }
          });
          return _setPrototypeOf(Wrapper, Class);
      };
      return _wrapNativeSuper(Class2);
  }
  function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
          return true;
      } catch (e) {
          return false;
      }
  }
  function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
          } else {
              result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
      };
  }
  /* proxy-compat-disable */ /**
   * Copyright (C) 2018 salesforce.com, inc.
   */ /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function invariant(value, msg) {
      if (!value) {
          throw new Error("Invariant Violation: ".concat(msg));
      }
  }
  function isTrue$1(value, msg) {
      if (!value) {
          throw new Error("Assert Violation: ".concat(msg));
      }
  }
  function isFalse$1(value, msg) {
      if (value) {
          throw new Error("Assert Violation: ".concat(msg));
      }
  }
  function fail(msg) {
      throw new Error(msg);
  }
  var assert = /*#__PURE__*/ Object.freeze({
      __proto__: null,
      invariant: invariant,
      isTrue: isTrue$1,
      isFalse: isFalse$1,
      fail: fail
  });
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var assign = Object.assign, create = Object.create, defineProperties = Object.defineProperties, defineProperty = Object.defineProperty, freeze = Object.freeze, getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor, getOwnPropertyNames$1 = Object.getOwnPropertyNames, getPrototypeOf$1 = Object.getPrototypeOf, hasOwnProperty$1 = Object.hasOwnProperty, isFrozen = Object.isFrozen, keys = Object.keys, seal = Object.seal, setPrototypeOf = Object.setPrototypeOf;
  var isArray$1 = Array.isArray;
  var _prototype = Array.prototype, ArrayIndexOf = _prototype.indexOf, ArrayJoin = _prototype.join, ArrayMap = _prototype.map, ArrayPush$1 = _prototype.push, ArraySlice = _prototype.slice, ArraySplice = _prototype.splice, ArrayUnshift = _prototype.unshift, forEach = _prototype.forEach;
  var StringFromCharCode = String.fromCharCode;
  var _prototype1 = String.prototype, StringCharCodeAt = _prototype1.charCodeAt, StringReplace = _prototype1.replace, StringSlice = _prototype1.slice, StringToLowerCase = _prototype1.toLowerCase;
  function isUndefined$1(obj) {
      return obj === undefined;
  }
  function isNull(obj) {
      return obj === null;
  }
  function isTrue(obj) {
      return obj === true;
  }
  function isFalse(obj) {
      return obj === false;
  }
  function isBoolean(obj) {
      return typeof obj === "boolean";
  }
  function isFunction$1(obj) {
      return typeof obj === "function";
  }
  function isObject(obj) {
      return typeof obj === "object";
  }
  function isString(obj) {
      return typeof obj === "string";
  }
  function isNumber(obj) {
      return typeof obj === "number";
  }
  function noop() {
  /* Do nothing */ }
  var OtS$1 = {}.toString;
  function toString$1(obj) {
      if (obj && obj.toString) {
          // Arrays might hold objects with "null" prototype So using
          // Array.prototype.toString directly will cause an error Iterate through
          // all the items and handle individually.
          if (isArray$1(obj)) {
              return ArrayJoin.call(ArrayMap.call(obj, toString$1), ",");
          }
          return obj.toString();
      } else if (typeof obj === "object") {
          return OtS$1.call(obj);
      } else {
          return obj + "";
      }
  }
  function getPropertyDescriptor(o, p) {
      do {
          var _$d = getOwnPropertyDescriptor$1(o, p);
          if (!isUndefined$1(_$d)) {
              return _$d;
          }
          o = getPrototypeOf$1(o);
      }while (o !== null);
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ /**
   * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and
   * ariaGrabbed) are deprecated:
   * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes
   *
   * The above list of 46 aria attributes is consistent with the following resources:
   * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060
   * https://wicg.github.io/aom/spec/aria-reflection.html
   */ var AriaPropertyNames = [
      "ariaActiveDescendant",
      "ariaAtomic",
      "ariaAutoComplete",
      "ariaBusy",
      "ariaChecked",
      "ariaColCount",
      "ariaColIndex",
      "ariaColSpan",
      "ariaControls",
      "ariaCurrent",
      "ariaDescribedBy",
      "ariaDetails",
      "ariaDisabled",
      "ariaErrorMessage",
      "ariaExpanded",
      "ariaFlowTo",
      "ariaHasPopup",
      "ariaHidden",
      "ariaInvalid",
      "ariaKeyShortcuts",
      "ariaLabel",
      "ariaLabelledBy",
      "ariaLevel",
      "ariaLive",
      "ariaModal",
      "ariaMultiLine",
      "ariaMultiSelectable",
      "ariaOrientation",
      "ariaOwns",
      "ariaPlaceholder",
      "ariaPosInSet",
      "ariaPressed",
      "ariaReadOnly",
      "ariaRelevant",
      "ariaRequired",
      "ariaRoleDescription",
      "ariaRowCount",
      "ariaRowIndex",
      "ariaRowSpan",
      "ariaSelected",
      "ariaSetSize",
      "ariaSort",
      "ariaValueMax",
      "ariaValueMin",
      "ariaValueNow",
      "ariaValueText",
      "role", 
  ];
  var ref = /*@__PURE__*/ function() {
      var AriaAttrNameToPropNameMap1 = create(null);
      var AriaPropNameToAttrNameMap1 = create(null);
      // Synthetic creation of all AOM property descriptors for Custom Elements
      forEach.call(AriaPropertyNames, function(propName2) {
          var attrName = StringToLowerCase.call(StringReplace.call(propName2, /^aria/, function() {
              return "aria-";
          }));
          AriaAttrNameToPropNameMap1[attrName] = propName2;
          AriaPropNameToAttrNameMap1[propName2] = attrName;
      });
      return {
          AriaAttrNameToPropNameMap: AriaAttrNameToPropNameMap1,
          AriaPropNameToAttrNameMap: AriaPropNameToAttrNameMap1
      };
  }(), AriaPropNameToAttrNameMap = ref.AriaPropNameToAttrNameMap;
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ // Inspired from: https://mathiasbynens.be/notes/globalthis
  var _globalThis = /*@__PURE__*/ function() {
      // On recent browsers, `globalThis` is already defined. In this case return it directly.
      if (typeof globalThis === "object") {
          return globalThis;
      }
      var _globalThis1;
      try {
          // eslint-disable-next-line no-extend-native
          Object.defineProperty(Object.prototype, "__magic__", {
              get: function get1() {
                  return this;
              },
              configurable: true
          });
          // __magic__ is undefined in Safari 10 and IE10 and older.
          // @ts-ignore
          // eslint-disable-next-line no-undef
          _globalThis1 = __magic__;
          // @ts-ignore
          delete Object.prototype.__magic__;
      } catch (ex) {
      // In IE8, Object.defineProperty only works on DOM objects.
      } finally{
          // If the magic above fails for some reason we assume that we are in a legacy browser.
          // Assume `window` exists in this case.
          if (typeof _globalThis1 === "undefined") {
              // @ts-ignore
              _globalThis1 = window;
          }
      }
      return _globalThis1;
  }();
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var KEY__IS_NATIVE_SHADOW_ROOT_DEFINED = "$isNativeShadowRootDefined$";
  var KEY__SHADOW_RESOLVER = "$shadowResolver$";
  var KEY__SHADOW_TOKEN = "$shadowToken$";
  var KEY__SYNTHETIC_MODE = "$$lwc-synthetic-mode";
  var KEY__SCOPED_CSS = "$scoped$";
  /**
   * Map composed of properties to attributes not following the HTML property to attribute mapping
   * convention.
   */ var NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING = new Map([
      [
          "accessKey",
          "accesskey"
      ],
      [
          "readOnly",
          "readonly"
      ],
      [
          "tabIndex",
          "tabindex"
      ],
      [
          "bgColor",
          "bgcolor"
      ],
      [
          "colSpan",
          "colspan"
      ],
      [
          "rowSpan",
          "rowspan"
      ],
      [
          "contentEditable",
          "contenteditable"
      ],
      [
          "crossOrigin",
          "crossorigin"
      ],
      [
          "dateTime",
          "datetime"
      ],
      [
          "formAction",
          "formaction"
      ],
      [
          "isMap",
          "ismap"
      ],
      [
          "maxLength",
          "maxlength"
      ],
      [
          "minLength",
          "minlength"
      ],
      [
          "noValidate",
          "novalidate"
      ],
      [
          "useMap",
          "usemap"
      ],
      [
          "htmlFor",
          "for"
      ], 
  ]);
  /**
   * Map associating previously transformed HTML property into HTML attribute.
   */ var CACHED_PROPERTY_ATTRIBUTE_MAPPING = new Map();
  function htmlPropertyToAttribute(propName3) {
      var ariaAttributeName = AriaPropNameToAttrNameMap[propName3];
      if (!isUndefined$1(ariaAttributeName)) {
          return ariaAttributeName;
      }
      var specialAttributeName = NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING.get(propName3);
      if (!isUndefined$1(specialAttributeName)) {
          return specialAttributeName;
      }
      var cachedAttributeName = CACHED_PROPERTY_ATTRIBUTE_MAPPING.get(propName3);
      if (!isUndefined$1(cachedAttributeName)) {
          return cachedAttributeName;
      }
      var attributeName = "";
      for(var _$i1 = 0, len2 = propName3.length; _$i1 < len2; _$i1++){
          var code = StringCharCodeAt.call(propName3, _$i1);
          if (code >= 65 && code <= 90 // "Z"
          ) {
              attributeName += "-" + StringFromCharCode(code + 32);
          } else {
              attributeName += StringFromCharCode(code);
          }
      }
      CACHED_PROPERTY_ATTRIBUTE_MAPPING.set(propName3, attributeName);
      return attributeName;
  }
  var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  var XLINK_NAMESPACE = "http://www.w3.org/1999/xlink";
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ // Increment whenever the LWC template compiler changes
  var LWC_VERSION = "2.13.3";
  var LWC_VERSION_COMMENT_REGEX = /\/\*LWC compiler v([\d.]+)\*\/\s*}/;
  /** version: 2.13.3 */ /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function detect(propName4) {
      return Object.getOwnPropertyDescriptor(Element.prototype, propName4) === undefined;
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var nodeToAriaPropertyValuesMap = new WeakMap();
  function getAriaPropertyMap(elm2) {
      var map = nodeToAriaPropertyValuesMap.get(elm2);
      if (map === undefined) {
          map = {};
          nodeToAriaPropertyValuesMap.set(elm2, map);
      }
      return map;
  }
  function getNormalizedAriaPropertyValue(value) {
      return value == null ? null : String(value);
  }
  function createAriaPropertyPropertyDescriptor(propName5, attrName) {
      return {
          get: function get1() {
              var map = getAriaPropertyMap(this);
              if (hasOwnProperty$1.call(map, propName5)) {
                  return map[propName5];
              }
              // otherwise just reflect what's in the attribute
              return this.hasAttribute(attrName) ? this.getAttribute(attrName) : null;
          },
          set: function set1(newValue) {
              var normalizedValue = getNormalizedAriaPropertyValue(newValue);
              var map = getAriaPropertyMap(this);
              map[propName5] = normalizedValue;
              // reflect into the corresponding attribute
              if (newValue === null) {
                  this.removeAttribute(attrName);
              } else {
                  this.setAttribute(attrName, newValue);
              }
          },
          configurable: true,
          enumerable: true
      };
  }
  function patch$1(propName6) {
      // Typescript is inferring the wrong function type for this particular
      // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
      // @ts-ignore type-mismatch
      var attrName = AriaPropNameToAttrNameMap[propName6];
      var descriptor = createAriaPropertyPropertyDescriptor(propName6, attrName);
      Object.defineProperty(Element.prototype, propName6, descriptor);
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var ElementPrototypeAriaPropertyNames = keys(AriaPropNameToAttrNameMap);
  for(var _$i = 0, len = ElementPrototypeAriaPropertyNames.length; _$i < len; _$i += 1){
      var propName = ElementPrototypeAriaPropertyNames[_$i];
      if (detect(propName)) {
          patch$1(propName);
      }
  }
  /**
   * Copyright (C) 2018 salesforce.com, inc.
   */ /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var features = {
      ENABLE_ELEMENT_PATCH: null,
      ENABLE_FORCE_NATIVE_SHADOW_MODE_FOR_TEST: null,
      ENABLE_HMR: null,
      ENABLE_HTML_COLLECTIONS_PATCH: null,
      ENABLE_INNER_OUTER_TEXT_PATCH: null,
      ENABLE_MIXED_SHADOW_MODE: null,
      ENABLE_NODE_LIST_PATCH: null,
      ENABLE_NODE_PATCH: null,
      ENABLE_REACTIVE_SETTER: null,
      ENABLE_WIRE_SYNC_EMIT: null
  };
  if (!_globalThis.lwcRuntimeFlags) {
      Object.defineProperty(_globalThis, "lwcRuntimeFlags", {
          value: create(null)
      });
  }
  var runtimeFlags = _globalThis.lwcRuntimeFlags;
  /**
   * Set the value at runtime of a given feature flag. This method only be invoked once per feature
   * flag. It is meant to be used during the app initialization.
   */ function setFeatureFlag(name1, value) {
      if (!isBoolean(value)) {
          var message = 'Failed to set the value "'.concat(value, '" for the runtime feature flag "').concat(name1, '". Runtime feature flags can only be set to a boolean value.');
          if (process.env.NODE_ENV !== "production") {
              throw new TypeError(message);
          } else {
              // eslint-disable-next-line no-console
              console.error(message);
              return;
          }
      }
      if (isUndefined$1(features[name1])) {
          var availableFlags = keys(features).map(function(name) {
              return '"'.concat(name, '"');
          }).join(", ");
          // eslint-disable-next-line no-console
          console.warn('Failed to set the value "'.concat(value, '" for the runtime feature flag "').concat(name1, '" because it is undefined. Available flags: ').concat(availableFlags, "."));
          return;
      }
      if (process.env.NODE_ENV !== "production") {
          // Allow the same flag to be set more than once outside of production to enable testing
          runtimeFlags[name1] = value;
      } else {
          // Disallow the same flag to be set more than once in production
          var runtimeValue = runtimeFlags[name1];
          if (!isUndefined$1(runtimeValue)) {
              // eslint-disable-next-line no-console
              console.error('Failed to set the value "'.concat(value, '" for the runtime feature flag "').concat(name1, '". "').concat(name1, '" has already been set with the value "').concat(runtimeValue, '".'));
              return;
          }
          defineProperty(runtimeFlags, name1, {
              value: value
          });
      }
  }
  /**
   * Set the value at runtime of a given feature flag. This method should only be used for testing
   * purposes. It is a no-op when invoked in production mode.
   */ function setFeatureFlagForTest(name, value) {
      if (process.env.NODE_ENV !== "production") {
          setFeatureFlag(name, value);
      }
  }
  /** version: 2.13.3 */ /* proxy-compat-disable */ /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var nextTickCallbackQueue = [];
  var SPACE_CHAR = 32;
  var EmptyObject = seal(create(null));
  var EmptyArray = seal([]);
  function flushCallbackQueue() {
      if (process.env.NODE_ENV !== "production") {
          if (nextTickCallbackQueue.length === 0) {
              throw new Error("Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.");
          }
      }
      var callbacks = nextTickCallbackQueue;
      nextTickCallbackQueue = []; // reset to a new queue
      for(var _$i2 = 0, len3 = callbacks.length; _$i2 < len3; _$i2 += 1){
          callbacks[_$i2]();
      }
  }
  function addCallbackToNextTick(callback) {
      if (process.env.NODE_ENV !== "production") {
          if (!isFunction$1(callback)) {
              throw new Error("Internal Error: addCallbackToNextTick() can only accept a function callback");
          }
      }
      if (nextTickCallbackQueue.length === 0) {
          Promise.resolve().then(flushCallbackQueue);
      }
      ArrayPush$1.call(nextTickCallbackQueue, callback);
  }
  function guid() {
      var s4 = function s4() {
          return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      };
      return s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
  }
  // Borrowed from Vue template compiler.
  // https://github.com/vuejs/vue/blob/531371b818b0e31a989a06df43789728f23dc4e8/src/platforms/web/util/style.js#L5-L16
  var DECLARATION_DELIMITER = /;(?![^(]*\))/g;
  var PROPERTY_DELIMITER = /:(.+)/;
  function parseStyleText(cssText) {
      var styleMap = {};
      var declarations = cssText.split(DECLARATION_DELIMITER);
      var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;
      try {
          for(var _iterator2 = declarations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
              var declaration = _step2.value;
              if (declaration) {
                  var ref1 = _slicedToArray(declaration.split(PROPERTY_DELIMITER), 2), prop = ref1[0], value = ref1[1];
                  if (prop !== undefined && value !== undefined) {
                      styleMap[prop.trim()] = value.trim();
                  }
              }
          }
      } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
      } finally{
          try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                  _iterator2.return();
              }
          } finally{
              if (_didIteratorError2) {
                  throw _iteratorError2;
              }
          }
      }
      return styleMap;
  }
  // Make a shallow copy of an object but omit the given key
  function cloneAndOmitKey(object, keyToOmit) {
      var result = {};
      var _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = undefined;
      try {
          for(var _iterator3 = Object.keys(object)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){
              var key = _step3.value;
              if (key !== keyToOmit) {
                  result[key] = object[key];
              }
          }
      } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
      } finally{
          try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                  _iterator3.return();
              }
          } finally{
              if (_didIteratorError3) {
                  throw _iteratorError3;
              }
          }
      }
      return result;
  }
  function flattenStylesheets(stylesheets) {
      var list = [];
      var _iteratorNormalCompletion4 = true, _didIteratorError4 = false, _iteratorError4 = undefined;
      try {
          for(var _iterator4 = stylesheets[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true){
              var stylesheet = _step4.value;
              if (!Array.isArray(stylesheet)) {
                  list.push(stylesheet);
              } else {
                  var _list;
                  (_list = list).push.apply(_list, _toConsumableArray(flattenStylesheets(stylesheet)));
              }
          }
      } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
      } finally{
          try {
              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                  _iterator4.return();
              }
          } finally{
              if (_didIteratorError4) {
                  throw _iteratorError4;
              }
          }
      }
      return list;
  }
  //
  // Primitives
  //
  var ssr$1;
  function setSsr(ssrImpl) {
      ssr$1 = ssrImpl;
  }
  var isNativeShadowDefined$1;
  function setIsNativeShadowDefined(isNativeShadowDefinedImpl) {
      isNativeShadowDefined$1 = isNativeShadowDefinedImpl;
  }
  var isSyntheticShadowDefined$1;
  function setIsSyntheticShadowDefined(isSyntheticShadowDefinedImpl) {
      isSyntheticShadowDefined$1 = isSyntheticShadowDefinedImpl;
  }
  var HTMLElementExported$1;
  function setHTMLElement(HTMLElementImpl) {
      HTMLElementExported$1 = HTMLElementImpl;
  }
  var isHydrating$1;
  function setIsHydrating$1(isHydratingImpl) {
      isHydrating$1 = isHydratingImpl;
  }
  var insert$1;
  function setInsert(insertImpl) {
      insert$1 = insertImpl;
  }
  var remove$1;
  function setRemove(removeImpl) {
      remove$1 = removeImpl;
  }
  var createElement$2;
  function setCreateElement(createElementImpl) {
      createElement$2 = createElementImpl;
  }
  var createText$1;
  function setCreateText(createTextImpl) {
      createText$1 = createTextImpl;
  }
  var createComment$1;
  function setCreateComment(createCommentImpl) {
      createComment$1 = createCommentImpl;
  }
  var nextSibling$1;
  function setNextSibling(nextSiblingImpl) {
      nextSibling$1 = nextSiblingImpl;
  }
  var attachShadow$1;
  function setAttachShadow(attachShadowImpl) {
      attachShadow$1 = attachShadowImpl;
  }
  var getProperty$1;
  function setGetProperty(getPropertyImpl) {
      getProperty$1 = getPropertyImpl;
  }
  var setProperty$1;
  function setSetProperty(setPropertyImpl) {
      setProperty$1 = setPropertyImpl;
  }
  var setText$1;
  function setSetText(setTextImpl) {
      setText$1 = setTextImpl;
  }
  var getAttribute$1;
  function setGetAttribute(getAttributeImpl) {
      getAttribute$1 = getAttributeImpl;
  }
  var setAttribute$1;
  function setSetAttribute(setAttributeImpl) {
      setAttribute$1 = setAttributeImpl;
  }
  var removeAttribute$1;
  function setRemoveAttribute(removeAttributeImpl) {
      removeAttribute$1 = removeAttributeImpl;
  }
  var addEventListener$1;
  function setAddEventListener(addEventListenerImpl) {
      addEventListener$1 = addEventListenerImpl;
  }
  var removeEventListener$1;
  function setRemoveEventListener(removeEventListenerImpl) {
      removeEventListener$1 = removeEventListenerImpl;
  }
  var dispatchEvent$1;
  function setDispatchEvent(dispatchEventImpl) {
      dispatchEvent$1 = dispatchEventImpl;
  }
  var getClassList$1;
  function setGetClassList(getClassListImpl) {
      getClassList$1 = getClassListImpl;
  }
  var setCSSStyleProperty$1;
  function setSetCSSStyleProperty(setCSSStylePropertyImpl) {
      setCSSStyleProperty$1 = setCSSStylePropertyImpl;
  }
  var getBoundingClientRect$1;
  function setGetBoundingClientRect(getBoundingClientRectImpl) {
      getBoundingClientRect$1 = getBoundingClientRectImpl;
  }
  var querySelector$1;
  function setQuerySelector(querySelectorImpl) {
      querySelector$1 = querySelectorImpl;
  }
  var querySelectorAll$1;
  function setQuerySelectorAll(querySelectorAllImpl) {
      querySelectorAll$1 = querySelectorAllImpl;
  }
  var getElementsByTagName$1;
  function setGetElementsByTagName(getElementsByTagNameImpl) {
      getElementsByTagName$1 = getElementsByTagNameImpl;
  }
  var getElementsByClassName$1;
  function setGetElementsByClassName(getElementsByClassNameImpl) {
      getElementsByClassName$1 = getElementsByClassNameImpl;
  }
  var getChildren$1;
  function setGetChildren(getChildrenImpl) {
      getChildren$1 = getChildrenImpl;
  }
  var getChildNodes$1;
  function setGetChildNodes(getChildNodesImpl) {
      getChildNodes$1 = getChildNodesImpl;
  }
  var getFirstChild$1;
  function setGetFirstChild(getFirstChildImpl) {
      getFirstChild$1 = getFirstChildImpl;
  }
  var getFirstElementChild$1;
  function setGetFirstElementChild(getFirstElementChildImpl) {
      getFirstElementChild$1 = getFirstElementChildImpl;
  }
  var getLastChild$1;
  function setGetLastChild(getLastChildImpl) {
      getLastChild$1 = getLastChildImpl;
  }
  var getLastElementChild$1;
  function setGetLastElementChild(getLastElementChildImpl) {
      getLastElementChild$1 = getLastElementChildImpl;
  }
  var isConnected$1;
  function setIsConnected(isConnectedImpl) {
      isConnected$1 = isConnectedImpl;
  }
  var insertGlobalStylesheet$1;
  function setInsertGlobalStylesheet(insertGlobalStylesheetImpl) {
      insertGlobalStylesheet$1 = insertGlobalStylesheetImpl;
  }
  var insertStylesheet$1;
  function setInsertStylesheet(insertStylesheetImpl) {
      insertStylesheet$1 = insertStylesheetImpl;
  }
  var assertInstanceOfHTMLElement$1;
  function setAssertInstanceOfHTMLElement(assertInstanceOfHTMLElementImpl) {
      assertInstanceOfHTMLElement$1 = assertInstanceOfHTMLElementImpl;
  }
  var defineCustomElement$1;
  function setDefineCustomElement(defineCustomElementImpl) {
      defineCustomElement$1 = defineCustomElementImpl;
  }
  var getCustomElement$1;
  function setGetCustomElement(getCustomElementImpl) {
      getCustomElement$1 = getCustomElementImpl;
  }
  /*
   * Copyright (c) 2019, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var TargetToReactiveRecordMap = new WeakMap();
  function getReactiveRecord(target) {
      var reactiveRecord = TargetToReactiveRecordMap.get(target);
      if (isUndefined$1(reactiveRecord)) {
          var newRecord = create(null);
          reactiveRecord = newRecord;
          TargetToReactiveRecordMap.set(target, newRecord);
      }
      return reactiveRecord;
  }
  var currentReactiveObserver = null;
  function valueMutated(target, key) {
      var reactiveRecord = TargetToReactiveRecordMap.get(target);
      if (!isUndefined$1(reactiveRecord)) {
          var reactiveObservers = reactiveRecord[key];
          if (!isUndefined$1(reactiveObservers)) {
              for(var _$i3 = 0, len4 = reactiveObservers.length; _$i3 < len4; _$i3 += 1){
                  var ro = reactiveObservers[_$i3];
                  ro.notify();
              }
          }
      }
  }
  function valueObserved(target, key) {
      // We should determine if an active Observing Record is present to track mutations.
      if (currentReactiveObserver === null) {
          return;
      }
      var ro = currentReactiveObserver;
      var reactiveRecord = getReactiveRecord(target);
      var reactiveObservers = reactiveRecord[key];
      if (isUndefined$1(reactiveObservers)) {
          reactiveObservers = [];
          reactiveRecord[key] = reactiveObservers;
      } else if (reactiveObservers[0] === ro) {
          return; // perf optimization considering that most subscriptions will come from the same record
      }
      if (ArrayIndexOf.call(reactiveObservers, ro) === -1) {
          ro.link(reactiveObservers);
      }
  }
  var ReactiveObserver = /*#__PURE__*/ function() {
      function ReactiveObserver(callback) {
          _classCallCheck(this, ReactiveObserver);
          this.listeners = [];
          this.callback = callback;
      }
      _createClass(ReactiveObserver, [
          {
              key: "observe",
              value: function observe(job) {
                  var inceptionReactiveRecord = currentReactiveObserver;
                  currentReactiveObserver = this;
                  var error;
                  try {
                      job();
                  } catch (e) {
                      error = Object(e);
                  } finally{
                      currentReactiveObserver = inceptionReactiveRecord;
                      if (error !== undefined) {
                          throw error; // eslint-disable-line no-unsafe-finally
                      }
                  }
              }
          },
          {
              /**
       * This method is responsible for disconnecting the Reactive Observer
       * from any Reactive Record that has a reference to it, to prevent future
       * notifications about previously recorded access.
       */ key: "reset",
              value: function reset() {
                  var listeners = this.listeners;
                  var len5 = listeners.length;
                  if (len5 > 0) {
                      for(var _$i4 = 0; _$i4 < len5; _$i4 += 1){
                          var set = listeners[_$i4];
                          var pos = ArrayIndexOf.call(listeners[_$i4], this);
                          ArraySplice.call(set, pos, 1);
                      }
                      listeners.length = 0;
                  }
              }
          },
          {
              // friend methods
              key: "notify",
              value: function notify() {
                  this.callback.call(undefined, this);
              }
          },
          {
              key: "link",
              value: function link(reactiveObservers) {
                  ArrayPush$1.call(reactiveObservers, this);
                  // we keep track of observing records where the observing record was added to so we can do some clean up later on
                  ArrayPush$1.call(this.listeners, reactiveObservers);
              }
          }
      ]);
      return ReactiveObserver;
  }();
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function componentValueMutated(vm2, key) {
      valueMutated(vm2.component, key);
  }
  function componentValueObserved(vm3, key) {
      valueObserved(vm3.component, key);
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function getComponentTag(vm4) {
      return "<".concat(StringToLowerCase.call(vm4.tagName), ">");
  }
  // TODO [#1695]: Unify getComponentStack and getErrorComponentStack
  function getComponentStack(vm5) {
      var stack = [];
      var prefix = "";
      while(!isNull(vm5.owner)){
          ArrayPush$1.call(stack, prefix + getComponentTag(vm5));
          vm5 = vm5.owner;
          prefix += "	";
      }
      return ArrayJoin.call(stack, "\n");
  }
  function getErrorComponentStack(vm6) {
      var wcStack = [];
      var currentVm = vm6;
      while(!isNull(currentVm)){
          ArrayPush$1.call(wcStack, getComponentTag(currentVm));
          currentVm = currentVm.owner;
      }
      return wcStack.reverse().join("\n	");
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function addErrorComponentStack(vm7, error) {
      if (!isFrozen(error) && isUndefined$1(error.wcStack)) {
          var wcStack = getErrorComponentStack(vm7);
          defineProperty(error, "wcStack", {
              get: function get1() {
                  return wcStack;
              }
          });
      }
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function log(method, message, vm8) {
      var msg = "[LWC ".concat(method, "]: ").concat(message);
      if (!isUndefined$1(vm8)) {
          msg = "".concat(msg, "\n").concat(getComponentStack(vm8));
      }
      if (process.env.NODE_ENV === "test") {
          /* eslint-disable-next-line no-console */ console[method](msg);
          return;
      }
      try {
          throw new Error(msg);
      } catch (e) {
          /* eslint-disable-next-line no-console */ console[method](e);
      }
  }
  function logError(message, vm9) {
      log("error", message, vm9);
  }
  function logWarn(message, vm10) {
      log("warn", message, vm10);
  }
  /*
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function resolveCircularModuleDependency(fn) {
      var module = fn();
      return (module === null || module === void 0 ? void 0 : module.__esModule) ? module.default : module;
  }
  function isCircularModuleDependency(obj) {
      return isFunction$1(obj) && hasOwnProperty$1.call(obj, "__circular__");
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ // This is a temporary workaround to get the @lwc/engine-server to evaluate in node without having
  // to inject at runtime.
  var HTMLElementConstructor$1 = typeof HTMLElement !== "undefined" ? HTMLElement : function HTMLElementConstructor$1() {};
  var HTMLElementPrototype = HTMLElementConstructor$1.prototype;
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ // These properties get added to LWCElement.prototype publicProps automatically
  var defaultDefHTMLPropertyNames = [
      "accessKey",
      "dir",
      "draggable",
      "hidden",
      "id",
      "lang",
      "spellcheck",
      "tabIndex",
      "title", 
  ];
  function offsetPropertyErrorMessage(name) {
      return "Using the `".concat(name, "` property is an anti-pattern because it rounds the value to an integer. Instead, use the `getBoundingClientRect` method to obtain fractional values for the size of an element and its position relative to the viewport.");
  }
  // Global HTML Attributes & Properties
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes
  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement
  var globalHTMLProperties = assign(create(null), {
      accessKey: {
          attribute: "accesskey"
      },
      accessKeyLabel: {
          readOnly: true
      },
      className: {
          attribute: "class",
          error: "Using the `className` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the `classList` API instead."
      },
      contentEditable: {
          attribute: "contenteditable"
      },
      dataset: {
          readOnly: true,
          error: "Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead."
      },
      dir: {
          attribute: "dir"
      },
      draggable: {
          attribute: "draggable"
      },
      dropzone: {
          attribute: "dropzone",
          readOnly: true
      },
      hidden: {
          attribute: "hidden"
      },
      id: {
          attribute: "id"
      },
      inputMode: {
          attribute: "inputmode"
      },
      lang: {
          attribute: "lang"
      },
      slot: {
          attribute: "slot",
          error: "Using the `slot` property is an anti-pattern."
      },
      spellcheck: {
          attribute: "spellcheck"
      },
      style: {
          attribute: "style"
      },
      tabIndex: {
          attribute: "tabindex"
      },
      title: {
          attribute: "title"
      },
      translate: {
          attribute: "translate"
      },
      // additional "global attributes" that are not present in the link above.
      isContentEditable: {
          readOnly: true
      },
      offsetHeight: {
          readOnly: true,
          error: offsetPropertyErrorMessage("offsetHeight")
      },
      offsetLeft: {
          readOnly: true,
          error: offsetPropertyErrorMessage("offsetLeft")
      },
      offsetParent: {
          readOnly: true
      },
      offsetTop: {
          readOnly: true,
          error: offsetPropertyErrorMessage("offsetTop")
      },
      offsetWidth: {
          readOnly: true,
          error: offsetPropertyErrorMessage("offsetWidth")
      },
      role: {
          attribute: "role"
      }
  });
  var controlledElement = null;
  var controlledAttributeName;
  function isAttributeLocked(elm3, attrName) {
      return elm3 !== controlledElement || attrName !== controlledAttributeName;
  }
  function lockAttribute(_elm, _key) {
      controlledElement = null;
      controlledAttributeName = undefined;
  }
  function unlockAttribute(elm4, key) {
      controlledElement = elm4;
      controlledAttributeName = key;
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ /**
   * This is a descriptor map that contains
   * all standard properties that a Custom Element can support (including AOM properties), which
   * determines what kind of capabilities the Base HTML Element and
   * Base Lightning Element should support.
   */ var HTMLElementOriginalDescriptors = create(null);
  forEach.call(keys(AriaPropNameToAttrNameMap), function(propName) {
      // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
      // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.
      var descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);
      if (!isUndefined$1(descriptor)) {
          HTMLElementOriginalDescriptors[propName] = descriptor;
      }
  });
  forEach.call(defaultDefHTMLPropertyNames, function(propName) {
      // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
      // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into
      // this category, so, better to be sure.
      var descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);
      if (!isUndefined$1(descriptor)) {
          HTMLElementOriginalDescriptors[propName] = descriptor;
      }
  });
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function generateDataDescriptor(options) {
      return assign({
          configurable: true,
          enumerable: true,
          writable: true
      }, options);
  }
  function generateAccessorDescriptor(options) {
      return assign({
          configurable: true,
          enumerable: true
      }, options);
  }
  var isDomMutationAllowed = false;
  function unlockDomMutation() {
      if (process.env.NODE_ENV === "production") {
          // this method should never leak to prod
          throw new ReferenceError();
      }
      isDomMutationAllowed = true;
  }
  function lockDomMutation() {
      if (process.env.NODE_ENV === "production") {
          // this method should never leak to prod
          throw new ReferenceError();
      }
      isDomMutationAllowed = false;
  }
  function logMissingPortalError(name, type) {
      return logError("The `".concat(name, "` ").concat(type, ' is available only on elements that use the `lwc:dom="manual"` directive.'));
  }
  function patchElementWithRestrictions(elm5, options) {
      if (process.env.NODE_ENV === "production") {
          // this method should never leak to prod
          throw new ReferenceError();
      }
      var originalOuterHTMLDescriptor = getPropertyDescriptor(elm5, "outerHTML");
      var descriptors = {
          outerHTML: generateAccessorDescriptor({
              get: function get1() {
                  return originalOuterHTMLDescriptor.get.call(this);
              },
              set: function set1(_value) {
                  throw new TypeError("Invalid attempt to set outerHTML on Element.");
              }
          })
      };
      // Apply extra restriction related to DOM manipulation if the element is not a portal.
      if (!options.isLight && !options.isPortal) {
          var appendChild1 = elm5.appendChild, insertBefore1 = elm5.insertBefore, removeChild1 = elm5.removeChild, replaceChild1 = elm5.replaceChild;
          var originalNodeValueDescriptor = getPropertyDescriptor(elm5, "nodeValue");
          var originalInnerHTMLDescriptor = getPropertyDescriptor(elm5, "innerHTML");
          var originalTextContentDescriptor = getPropertyDescriptor(elm5, "textContent");
          assign(descriptors, {
              appendChild: generateDataDescriptor({
                  value: function value(aChild) {
                      logMissingPortalError("appendChild", "method");
                      return appendChild1.call(this, aChild);
                  }
              }),
              insertBefore: generateDataDescriptor({
                  value: function value(newNode, referenceNode) {
                      if (!isDomMutationAllowed) {
                          logMissingPortalError("insertBefore", "method");
                      }
                      return insertBefore1.call(this, newNode, referenceNode);
                  }
              }),
              removeChild: generateDataDescriptor({
                  value: function value(aChild) {
                      if (!isDomMutationAllowed) {
                          logMissingPortalError("removeChild", "method");
                      }
                      return removeChild1.call(this, aChild);
                  }
              }),
              replaceChild: generateDataDescriptor({
                  value: function value(newChild, oldChild) {
                      logMissingPortalError("replaceChild", "method");
                      return replaceChild1.call(this, newChild, oldChild);
                  }
              }),
              nodeValue: generateAccessorDescriptor({
                  get: function get1() {
                      return originalNodeValueDescriptor.get.call(this);
                  },
                  set: function set1(value) {
                      if (!isDomMutationAllowed) {
                          logMissingPortalError("nodeValue", "property");
                      }
                      originalNodeValueDescriptor.set.call(this, value);
                  }
              }),
              textContent: generateAccessorDescriptor({
                  get: function get1() {
                      return originalTextContentDescriptor.get.call(this);
                  },
                  set: function set1(value) {
                      logMissingPortalError("textContent", "property");
                      originalTextContentDescriptor.set.call(this, value);
                  }
              }),
              innerHTML: generateAccessorDescriptor({
                  get: function get1() {
                      return originalInnerHTMLDescriptor.get.call(this);
                  },
                  set: function set1(value) {
                      logMissingPortalError("innerHTML", "property");
                      return originalInnerHTMLDescriptor.set.call(this, value);
                  }
              })
          });
      }
      defineProperties(elm5, descriptors);
  }
  function getShadowRootRestrictionsDescriptors(sr) {
      if (process.env.NODE_ENV === "production") {
          // this method should never leak to prod
          throw new ReferenceError();
      }
      // Disallowing properties in dev mode only to avoid people doing the wrong
      // thing when using the real shadow root, because if that's the case,
      // the component will not work when running with synthetic shadow.
      var originalAddEventListener = sr.addEventListener;
      var originalInnerHTMLDescriptor = getPropertyDescriptor(sr, "innerHTML");
      var originalTextContentDescriptor = getPropertyDescriptor(sr, "textContent");
      return {
          innerHTML: generateAccessorDescriptor({
              get: function get1() {
                  return originalInnerHTMLDescriptor.get.call(this);
              },
              set: function set1(_value) {
                  throw new TypeError("Invalid attempt to set innerHTML on ShadowRoot.");
              }
          }),
          textContent: generateAccessorDescriptor({
              get: function get1() {
                  return originalTextContentDescriptor.get.call(this);
              },
              set: function set1(_value) {
                  throw new TypeError("Invalid attempt to set textContent on ShadowRoot.");
              }
          }),
          addEventListener: generateDataDescriptor({
              value: function value(type, listener, options) {
                  // TODO [#420]: this is triggered when the component author attempts to add a listener
                  // programmatically into its Component's shadow root
                  if (!isUndefined$1(options)) {
                      logError("The `addEventListener` method on ShadowRoot does not support any options.", getAssociatedVMIfPresent(this));
                  }
                  // Typescript does not like it when you treat the `arguments` object as an array
                  // @ts-ignore type-mismatch
                  return originalAddEventListener.apply(this, arguments);
              }
          })
      };
  }
  // Custom Elements Restrictions:
  // -----------------------------
  function getCustomElementRestrictionsDescriptors(elm6) {
      if (process.env.NODE_ENV === "production") {
          // this method should never leak to prod
          throw new ReferenceError();
      }
      var originalAddEventListener = elm6.addEventListener;
      var originalInnerHTMLDescriptor = getPropertyDescriptor(elm6, "innerHTML");
      var originalOuterHTMLDescriptor = getPropertyDescriptor(elm6, "outerHTML");
      var originalTextContentDescriptor = getPropertyDescriptor(elm6, "textContent");
      return {
          innerHTML: generateAccessorDescriptor({
              get: function get1() {
                  return originalInnerHTMLDescriptor.get.call(this);
              },
              set: function set1(_value) {
                  throw new TypeError("Invalid attempt to set innerHTML on HTMLElement.");
              }
          }),
          outerHTML: generateAccessorDescriptor({
              get: function get1() {
                  return originalOuterHTMLDescriptor.get.call(this);
              },
              set: function set1(_value) {
                  throw new TypeError("Invalid attempt to set outerHTML on HTMLElement.");
              }
          }),
          textContent: generateAccessorDescriptor({
              get: function get1() {
                  return originalTextContentDescriptor.get.call(this);
              },
              set: function set1(_value) {
                  throw new TypeError("Invalid attempt to set textContent on HTMLElement.");
              }
          }),
          addEventListener: generateDataDescriptor({
              value: function value(type, listener, options) {
                  // TODO [#420]: this is triggered when the component author attempts to add a listener
                  // programmatically into a lighting element node
                  if (!isUndefined$1(options)) {
                      logError("The `addEventListener` method in `LightningElement` does not support any options.", getAssociatedVMIfPresent(this));
                  }
                  // Typescript does not like it when you treat the `arguments` object as an array
                  // @ts-ignore type-mismatch
                  return originalAddEventListener.apply(this, arguments);
              }
          })
      };
  }
  function getComponentRestrictionsDescriptors() {
      if (process.env.NODE_ENV === "production") {
          // this method should never leak to prod
          throw new ReferenceError();
      }
      return {
          tagName: generateAccessorDescriptor({
              get: function get1() {
                  throw new Error("Usage of property `tagName` is disallowed because the component itself does" + " not know which tagName will be used to create the element, therefore writing" + " code that check for that value is error prone.");
              },
              configurable: true,
              enumerable: false
          })
      };
  }
  function getLightningElementPrototypeRestrictionsDescriptors(proto) {
      if (process.env.NODE_ENV === "production") {
          // this method should never leak to prod
          throw new ReferenceError();
      }
      var originalDispatchEvent = proto.dispatchEvent;
      var descriptors = {
          dispatchEvent: generateDataDescriptor({
              value: function value(event) {
                  var vm11 = getAssociatedVM(this);
                  if (!isNull(event) && isObject(event)) {
                      var type = event.type;
                      if (!/^[a-z][a-z0-9_]*$/.test(type)) {
                          logError('Invalid event type "'.concat(type, '" dispatched in element ').concat(getComponentTag(vm11), ".") + " Event name must start with a lowercase letter and followed only lowercase" + " letters, numbers, and underscores", vm11);
                      }
                  }
                  // Typescript does not like it when you treat the `arguments` object as an array
                  // @ts-ignore type-mismatch
                  return originalDispatchEvent.apply(this, arguments);
              }
          })
      };
      forEach.call(getOwnPropertyNames$1(globalHTMLProperties), function(propName) {
          if (propName in proto) {
              return; // no need to redefine something that we are already exposing
          }
          descriptors[propName] = generateAccessorDescriptor({
              get: function get1() {
                  var _propName = globalHTMLProperties[propName], error = _propName.error, attribute = _propName.attribute;
                  var msg = [];
                  msg.push('Accessing the global HTML property "'.concat(propName, '" is disabled.'));
                  if (error) {
                      msg.push(error);
                  } else if (attribute) {
                      msg.push('Instead access it via `this.getAttribute("'.concat(attribute, '")`.'));
                  }
                  logError(msg.join("\n"), getAssociatedVM(this));
              },
              set: function set1() {
                  var readOnly = globalHTMLProperties[propName].readOnly;
                  if (readOnly) {
                      logError("The global HTML property `".concat(propName, "` is read-only."), getAssociatedVM(this));
                  }
              }
          });
      });
      return descriptors;
  }
  // This routine will prevent access to certain properties on a shadow root instance to guarantee
  // that all components will work fine in IE11 and other browsers without shadow dom support.
  function patchShadowRootWithRestrictions(sr) {
      defineProperties(sr, getShadowRootRestrictionsDescriptors(sr));
  }
  function patchCustomElementWithRestrictions(elm7) {
      var restrictionsDescriptors = getCustomElementRestrictionsDescriptors(elm7);
      var elmProto = getPrototypeOf$1(elm7);
      setPrototypeOf(elm7, create(elmProto, restrictionsDescriptors));
  }
  function patchComponentWithRestrictions(cmp) {
      defineProperties(cmp, getComponentRestrictionsDescriptors());
  }
  function patchLightningElementPrototypeWithRestrictions(proto) {
      defineProperties(proto, getLightningElementPrototypeRestrictionsDescriptors(proto));
  }
  /**
   * Copyright (C) 2017 salesforce.com, inc.
   */ var isArray = Array.isArray;
  var ObjectDotPrototype = Object.prototype, getPrototypeOf = Object.getPrototypeOf, ObjectCreate = Object.create, ObjectDefineProperty = Object.defineProperty, isExtensible = Object.isExtensible, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, preventExtensions = Object.preventExtensions, hasOwnProperty = Object.hasOwnProperty;
  var _prototype2 = Array.prototype, ArrayPush = _prototype2.push, ArrayConcat = _prototype2.concat;
  var OtS = {}.toString;
  function toString(obj) {
      if (obj && obj.toString) {
          return obj.toString();
      } else if (typeof obj === "object") {
          return OtS.call(obj);
      } else {
          return obj + "";
      }
  }
  function isUndefined(obj) {
      return obj === undefined;
  }
  function isFunction(obj) {
      return typeof obj === "function";
  }
  var proxyToValueMap = new WeakMap();
  function registerProxy(proxy, value) {
      proxyToValueMap.set(proxy, value);
  }
  var unwrap$1 = function(replicaOrAny) {
      return proxyToValueMap.get(replicaOrAny) || replicaOrAny;
  };
  var BaseProxyHandler = /*#__PURE__*/ function() {
      function BaseProxyHandler(membrane, value) {
          _classCallCheck(this, BaseProxyHandler);
          this.originalTarget = value;
          this.membrane = membrane;
      }
      _createClass(BaseProxyHandler, [
          {
              // Shared utility methods
              key: "wrapDescriptor",
              value: function wrapDescriptor(descriptor) {
                  if (hasOwnProperty.call(descriptor, "value")) {
                      descriptor.value = this.wrapValue(descriptor.value);
                  } else {
                      var originalSet = descriptor.set, originalGet = descriptor.get;
                      if (!isUndefined(originalGet)) {
                          descriptor.get = this.wrapGetter(originalGet);
                      }
                      if (!isUndefined(originalSet)) {
                          descriptor.set = this.wrapSetter(originalSet);
                      }
                  }
                  return descriptor;
              }
          },
          {
              key: "copyDescriptorIntoShadowTarget",
              value: function copyDescriptorIntoShadowTarget(shadowTarget, key) {
                  var originalTarget = this.originalTarget;
                  // Note: a property might get defined multiple times in the shadowTarget
                  //       but it will always be compatible with the previous descriptor
                  //       to preserve the object invariants, which makes these lines safe.
                  var originalDescriptor = getOwnPropertyDescriptor(originalTarget, key);
                  // TODO: it should be impossible for the originalDescriptor to ever be undefined, this `if` can be removed
                  /* istanbul ignore else */ if (!isUndefined(originalDescriptor)) {
                      var wrappedDesc = this.wrapDescriptor(originalDescriptor);
                      ObjectDefineProperty(shadowTarget, key, wrappedDesc);
                  }
              }
          },
          {
              key: "lockShadowTarget",
              value: function lockShadowTarget(shadowTarget) {
                  var _this = this;
                  var originalTarget = this.originalTarget;
                  var targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
                  targetKeys.forEach(function(key) {
                      _this.copyDescriptorIntoShadowTarget(shadowTarget, key);
                  });
                  var ref2 = this, tagPropertyKey = ref2.membrane.tagPropertyKey;
                  if (!isUndefined(tagPropertyKey) && !hasOwnProperty.call(shadowTarget, tagPropertyKey)) {
                      ObjectDefineProperty(shadowTarget, tagPropertyKey, ObjectCreate(null));
                  }
                  preventExtensions(shadowTarget);
              }
          },
          {
              // Shared Traps
              // TODO: apply() is never called
              /* istanbul ignore next */ key: "apply",
              value: function apply(shadowTarget, thisArg, argArray) {
              /* No op */ }
          },
          {
              // TODO: construct() is never called
              /* istanbul ignore next */ key: "construct",
              value: function construct(shadowTarget, argArray, newTarget) {
              /* No op */ }
          },
          {
              key: "get",
              value: function get1(shadowTarget, key) {
                  var ref3 = this, originalTarget = ref3.originalTarget, _$valueObserved = ref3.membrane.valueObserved;
                  var value = originalTarget[key];
                  _$valueObserved(originalTarget, key);
                  return this.wrapValue(value);
              }
          },
          {
              key: "has",
              value: function has(shadowTarget, key) {
                  var ref4 = this, originalTarget = ref4.originalTarget, _membrane = ref4.membrane, tagPropertyKey = _membrane.tagPropertyKey, _$valueObserved = _membrane.valueObserved;
                  _$valueObserved(originalTarget, key);
                  // since key is never going to be undefined, and tagPropertyKey might be undefined
                  // we can simply compare them as the second part of the condition.
                  return key in originalTarget || key === tagPropertyKey;
              }
          },
          {
              key: "ownKeys",
              value: function ownKeys(shadowTarget) {
                  var ref5 = this, originalTarget = ref5.originalTarget, tagPropertyKey = ref5.membrane.tagPropertyKey;
                  // if the membrane tag key exists and it is not in the original target, we add it to the keys.
                  var keys1 = isUndefined(tagPropertyKey) || hasOwnProperty.call(originalTarget, tagPropertyKey) ? [] : [
                      tagPropertyKey
                  ];
                  // small perf optimization using push instead of concat to avoid creating an extra array
                  ArrayPush.apply(keys1, getOwnPropertyNames(originalTarget));
                  ArrayPush.apply(keys1, getOwnPropertySymbols(originalTarget));
                  return keys1;
              }
          },
          {
              key: "isExtensible",
              value: function isExtensible1(shadowTarget) {
                  var originalTarget = this.originalTarget;
                  // optimization to avoid attempting to lock down the shadowTarget multiple times
                  if (!isExtensible(shadowTarget)) {
                      return false; // was already locked down
                  }
                  if (!isExtensible(originalTarget)) {
                      this.lockShadowTarget(shadowTarget);
                      return false;
                  }
                  return true;
              }
          },
          {
              key: "getPrototypeOf",
              value: function getPrototypeOf1(shadowTarget) {
                  var originalTarget = this.originalTarget;
                  return getPrototypeOf(originalTarget);
              }
          },
          {
              key: "getOwnPropertyDescriptor",
              value: function getOwnPropertyDescriptor1(shadowTarget, key) {
                  var ref6 = this, originalTarget = ref6.originalTarget, _membrane = ref6.membrane, _$valueObserved = _membrane.valueObserved, tagPropertyKey = _membrane.tagPropertyKey;
                  // keys looked up via getOwnPropertyDescriptor need to be reactive
                  _$valueObserved(originalTarget, key);
                  var desc = getOwnPropertyDescriptor(originalTarget, key);
                  if (isUndefined(desc)) {
                      if (key !== tagPropertyKey) {
                          return undefined;
                      }
                      // if the key is the membrane tag key, and is not in the original target,
                      // we produce a synthetic descriptor and install it on the shadow target
                      desc = {
                          value: undefined,
                          writable: false,
                          configurable: false,
                          enumerable: false
                      };
                      ObjectDefineProperty(shadowTarget, tagPropertyKey, desc);
                      return desc;
                  }
                  if (desc.configurable === false) {
                      // updating the descriptor to non-configurable on the shadow
                      this.copyDescriptorIntoShadowTarget(shadowTarget, key);
                  }
                  // Note: by accessing the descriptor, the key is marked as observed
                  // but access to the value, setter or getter (if available) cannot observe
                  // mutations, just like regular methods, in which case we just do nothing.
                  return this.wrapDescriptor(desc);
              }
          }
      ]);
      return BaseProxyHandler;
  }();
  var getterMap$1 = new WeakMap();
  var setterMap$1 = new WeakMap();
  var reverseGetterMap = new WeakMap();
  var reverseSetterMap = new WeakMap();
  var ReactiveProxyHandler = /*#__PURE__*/ function(BaseProxyHandler) {
      _inherits(ReactiveProxyHandler, BaseProxyHandler);
      var _super = _createSuper(ReactiveProxyHandler);
      function ReactiveProxyHandler() {
          _classCallCheck(this, ReactiveProxyHandler);
          return _super.apply(this, arguments);
      }
      _createClass(ReactiveProxyHandler, [
          {
              key: "wrapValue",
              value: function wrapValue(value) {
                  return this.membrane.getProxy(value);
              }
          },
          {
              key: "wrapGetter",
              value: function wrapGetter(originalGet) {
                  var wrappedGetter = getterMap$1.get(originalGet);
                  if (!isUndefined(wrappedGetter)) {
                      return wrappedGetter;
                  }
                  var handler = this;
                  var get = function get() {
                      // invoking the original getter with the original target
                      return handler.wrapValue(originalGet.call(unwrap$1(this)));
                  };
                  getterMap$1.set(originalGet, get);
                  reverseGetterMap.set(get, originalGet);
                  return get;
              }
          },
          {
              key: "wrapSetter",
              value: function wrapSetter(originalSet) {
                  var wrappedSetter = setterMap$1.get(originalSet);
                  if (!isUndefined(wrappedSetter)) {
                      return wrappedSetter;
                  }
                  var set = function set(v) {
                      // invoking the original setter with the original target
                      originalSet.call(unwrap$1(this), unwrap$1(v));
                  };
                  setterMap$1.set(originalSet, set);
                  reverseSetterMap.set(set, originalSet);
                  return set;
              }
          },
          {
              key: "unwrapDescriptor",
              value: function unwrapDescriptor(descriptor) {
                  if (hasOwnProperty.call(descriptor, "value")) {
                      // dealing with a data descriptor
                      descriptor.value = unwrap$1(descriptor.value);
                  } else {
                      var set = descriptor.set, get = descriptor.get;
                      if (!isUndefined(get)) {
                          descriptor.get = this.unwrapGetter(get);
                      }
                      if (!isUndefined(set)) {
                          descriptor.set = this.unwrapSetter(set);
                      }
                  }
                  return descriptor;
              }
          },
          {
              key: "unwrapGetter",
              value: function unwrapGetter(redGet) {
                  var reverseGetter = reverseGetterMap.get(redGet);
                  if (!isUndefined(reverseGetter)) {
                      return reverseGetter;
                  }
                  var handler = this;
                  var get = function get() {
                      // invoking the red getter with the proxy of this
                      return unwrap$1(redGet.call(handler.wrapValue(this)));
                  };
                  getterMap$1.set(get, redGet);
                  reverseGetterMap.set(redGet, get);
                  return get;
              }
          },
          {
              key: "unwrapSetter",
              value: function unwrapSetter(redSet) {
                  var reverseSetter = reverseSetterMap.get(redSet);
                  if (!isUndefined(reverseSetter)) {
                      return reverseSetter;
                  }
                  var handler = this;
                  var set = function set(v) {
                      // invoking the red setter with the proxy of this
                      redSet.call(handler.wrapValue(this), handler.wrapValue(v));
                  };
                  setterMap$1.set(set, redSet);
                  reverseSetterMap.set(redSet, set);
                  return set;
              }
          },
          {
              key: "set",
              value: function set1(shadowTarget, key, value) {
                  var ref7 = this, originalTarget = ref7.originalTarget, _$valueMutated = ref7.membrane.valueMutated;
                  var oldValue = originalTarget[key];
                  if (oldValue !== value) {
                      originalTarget[key] = value;
                      _$valueMutated(originalTarget, key);
                  } else if (key === "length" && isArray(originalTarget)) {
                      // fix for issue #236: push will add the new index, and by the time length
                      // is updated, the internal length is already equal to the new length value
                      // therefore, the oldValue is equal to the value. This is the forking logic
                      // to support this use case.
                      _$valueMutated(originalTarget, key);
                  }
                  return true;
              }
          },
          {
              key: "deleteProperty",
              value: function deleteProperty(shadowTarget, key) {
                  var ref8 = this, originalTarget = ref8.originalTarget, _$valueMutated = ref8.membrane.valueMutated;
                  delete originalTarget[key];
                  _$valueMutated(originalTarget, key);
                  return true;
              }
          },
          {
              key: "setPrototypeOf",
              value: function setPrototypeOf(shadowTarget, prototype) {
                  /* istanbul ignore else */ if (process.env.NODE_ENV !== "production") {
                      throw new Error("Invalid setPrototypeOf invocation for reactive proxy ".concat(toString(this.originalTarget), ". Prototype of reactive objects cannot be changed."));
                  }
              }
          },
          {
              key: "preventExtensions",
              value: function preventExtensions1(shadowTarget) {
                  if (isExtensible(shadowTarget)) {
                      var originalTarget = this.originalTarget;
                      preventExtensions(originalTarget);
                      // if the originalTarget is a proxy itself, it might reject
                      // the preventExtension call, in which case we should not attempt to lock down
                      // the shadow target.
                      // TODO: It should not actually be possible to reach this `if` statement.
                      // If a proxy rejects extensions, then calling preventExtensions will throw an error:
                      // https://codepen.io/nolanlawson-the-selector/pen/QWMOjbY
                      /* istanbul ignore if */ if (isExtensible(originalTarget)) {
                          return false;
                      }
                      this.lockShadowTarget(shadowTarget);
                  }
                  return true;
              }
          },
          {
              key: "defineProperty",
              value: function defineProperty(shadowTarget, key, descriptor) {
                  var ref9 = this, originalTarget = ref9.originalTarget, _membrane = ref9.membrane, _$valueMutated = _membrane.valueMutated, tagPropertyKey = _membrane.tagPropertyKey;
                  if (key === tagPropertyKey && !hasOwnProperty.call(originalTarget, key)) {
                      // To avoid leaking the membrane tag property into the original target, we must
                      // be sure that the original target doesn't have yet.
                      // NOTE: we do not return false here because Object.freeze and equivalent operations
                      // will attempt to set the descriptor to the same value, and expect no to throw. This
                      // is an small compromise for the sake of not having to diff the descriptors.
                      return true;
                  }
                  ObjectDefineProperty(originalTarget, key, this.unwrapDescriptor(descriptor));
                  // intentionally testing if false since it could be undefined as well
                  if (descriptor.configurable === false) {
                      this.copyDescriptorIntoShadowTarget(shadowTarget, key);
                  }
                  _$valueMutated(originalTarget, key);
                  return true;
              }
          }
      ]);
      return ReactiveProxyHandler;
  }(BaseProxyHandler);
  var getterMap = new WeakMap();
  var setterMap = new WeakMap();
  var ReadOnlyHandler = /*#__PURE__*/ function(BaseProxyHandler) {
      _inherits(ReadOnlyHandler, BaseProxyHandler);
      var _super = _createSuper(ReadOnlyHandler);
      function ReadOnlyHandler() {
          _classCallCheck(this, ReadOnlyHandler);
          return _super.apply(this, arguments);
      }
      _createClass(ReadOnlyHandler, [
          {
              key: "wrapValue",
              value: function wrapValue(value) {
                  return this.membrane.getReadOnlyProxy(value);
              }
          },
          {
              key: "wrapGetter",
              value: function wrapGetter(originalGet) {
                  var wrappedGetter = getterMap.get(originalGet);
                  if (!isUndefined(wrappedGetter)) {
                      return wrappedGetter;
                  }
                  var handler = this;
                  var get = function get() {
                      // invoking the original getter with the original target
                      return handler.wrapValue(originalGet.call(unwrap$1(this)));
                  };
                  getterMap.set(originalGet, get);
                  return get;
              }
          },
          {
              key: "wrapSetter",
              value: function wrapSetter(originalSet) {
                  var wrappedSetter = setterMap.get(originalSet);
                  if (!isUndefined(wrappedSetter)) {
                      return wrappedSetter;
                  }
                  var handler = this;
                  var set = function set(v) {
                      /* istanbul ignore else */ if (process.env.NODE_ENV !== "production") {
                          var originalTarget = handler.originalTarget;
                          throw new Error('Invalid mutation: Cannot invoke a setter on "'.concat(originalTarget, '". "').concat(originalTarget, '" is read-only.'));
                      }
                  };
                  setterMap.set(originalSet, set);
                  return set;
              }
          },
          {
              key: "set",
              value: function set1(shadowTarget, key, value) {
                  /* istanbul ignore else */ if (process.env.NODE_ENV !== "production") {
                      var originalTarget = this.originalTarget;
                      var msg = isArray(originalTarget) ? "Invalid mutation: Cannot mutate array at index ".concat(key.toString(), ". Array is read-only.") : 'Invalid mutation: Cannot set "'.concat(key.toString(), '" on "').concat(originalTarget, '". "').concat(originalTarget, '" is read-only.');
                      throw new Error(msg);
                  }
                  /* istanbul ignore next */ return false;
              }
          },
          {
              key: "deleteProperty",
              value: function deleteProperty(shadowTarget, key) {
                  /* istanbul ignore else */ if (process.env.NODE_ENV !== "production") {
                      var originalTarget = this.originalTarget;
                      throw new Error('Invalid mutation: Cannot delete "'.concat(key.toString(), '" on "').concat(originalTarget, '". "').concat(originalTarget, '" is read-only.'));
                  }
                  /* istanbul ignore next */ return false;
              }
          },
          {
              key: "setPrototypeOf",
              value: function setPrototypeOf(shadowTarget, prototype) {
                  /* istanbul ignore else */ if (process.env.NODE_ENV !== "production") {
                      var originalTarget = this.originalTarget;
                      throw new Error('Invalid prototype mutation: Cannot set prototype on "'.concat(originalTarget, '". "').concat(originalTarget, '" prototype is read-only.'));
                  }
              }
          },
          {
              key: "preventExtensions",
              value: function preventExtensions1(shadowTarget) {
                  /* istanbul ignore else */ if (process.env.NODE_ENV !== "production") {
                      var originalTarget = this.originalTarget;
                      throw new Error("Invalid mutation: Cannot preventExtensions on ".concat(originalTarget, '". "').concat(originalTarget, " is read-only."));
                  }
                  /* istanbul ignore next */ return false;
              }
          },
          {
              key: "defineProperty",
              value: function defineProperty(shadowTarget, key, descriptor) {
                  /* istanbul ignore else */ if (process.env.NODE_ENV !== "production") {
                      var originalTarget = this.originalTarget;
                      throw new Error('Invalid mutation: Cannot defineProperty "'.concat(key.toString(), '" on "').concat(originalTarget, '". "').concat(originalTarget, '" is read-only.'));
                  }
                  /* istanbul ignore next */ return false;
              }
          }
      ]);
      return ReadOnlyHandler;
  }(BaseProxyHandler);
  function extract(objectOrArray) {
      if (isArray(objectOrArray)) {
          return objectOrArray.map(function(item) {
              var original = unwrap$1(item);
              if (original !== item) {
                  return extract(original);
              }
              return item;
          });
      }
      var obj = ObjectCreate(getPrototypeOf(objectOrArray));
      var names = getOwnPropertyNames(objectOrArray);
      return ArrayConcat.call(names, getOwnPropertySymbols(objectOrArray)).reduce(function(seed, key) {
          var item = objectOrArray[key];
          var original = unwrap$1(item);
          if (original !== item) {
              seed[key] = extract(original);
          } else {
              seed[key] = item;
          }
          return seed;
      }, obj);
  }
  var formatter = {
      header: function(plainOrProxy) {
          var originalTarget = unwrap$1(plainOrProxy);
          // if originalTarget is falsy or not unwrappable, exit
          if (!originalTarget || originalTarget === plainOrProxy) {
              return null;
          }
          var obj = extract(plainOrProxy);
          return [
              "object",
              {
                  object: obj
              }
          ];
      },
      hasBody: function() {
          return false;
      },
      body: function() {
          return null;
      }
  };
  // Inspired from paulmillr/es6-shim
  // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L176-L185
  /* istanbul ignore next */ function getGlobal() {
      // the only reliable means to get the global object is `Function('return this')()`
      // However, this causes CSP violations in Chrome apps.
      if (typeof globalThis !== "undefined") {
          return globalThis;
      }
      if (typeof self !== "undefined") {
          return self;
      }
      if (typeof window !== "undefined") {
          return window;
      }
      if (typeof global !== "undefined") {
          return global;
      }
      // Gracefully degrade if not able to locate the global object
      return {};
  }
  function init() {
      /* istanbul ignore if */ if (process.env.NODE_ENV === "production") {
          // this method should never leak to prod
          throw new ReferenceError();
      }
      var global = getGlobal();
      // Custom Formatter for Dev Tools. To enable this, open Chrome Dev Tools
      //  - Go to Settings,
      //  - Under console, select "Enable custom formatters"
      // For more information, https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview
      var devtoolsFormatters = global.devtoolsFormatters || [];
      ArrayPush.call(devtoolsFormatters, formatter);
      global.devtoolsFormatters = devtoolsFormatters;
  }
  /* istanbul ignore else */ if (process.env.NODE_ENV !== "production") {
      init();
  }
  function defaultValueIsObservable(value) {
      // intentionally checking for null
      if (value === null) {
          return false;
      }
      // treat all non-object types, including undefined, as non-observable values
      if (typeof value !== "object") {
          return false;
      }
      if (isArray(value)) {
          return true;
      }
      var proto = getPrototypeOf(value);
      return proto === ObjectDotPrototype || proto === null || getPrototypeOf(proto) === null;
  }
  var defaultValueObserved = function(obj, key) {
  /* do nothing */ };
  var defaultValueMutated = function(obj, key) {
  /* do nothing */ };
  function createShadowTarget(value) {
      return isArray(value) ? [] : {};
  }
  var ObservableMembrane = /*#__PURE__*/ function() {
      function ObservableMembrane() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          _classCallCheck(this, ObservableMembrane);
          this.readOnlyObjectGraph = new WeakMap();
          this.reactiveObjectGraph = new WeakMap();
          var _$valueMutated = options.valueMutated, _$valueObserved = options.valueObserved, valueIsObservable = options.valueIsObservable, tagPropertyKey = options.tagPropertyKey;
          this.valueMutated = isFunction(_$valueMutated) ? _$valueMutated : defaultValueMutated;
          this.valueObserved = isFunction(_$valueObserved) ? _$valueObserved : defaultValueObserved;
          this.valueIsObservable = isFunction(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;
          this.tagPropertyKey = tagPropertyKey;
      }
      _createClass(ObservableMembrane, [
          {
              key: "getProxy",
              value: function getProxy(value) {
                  var unwrappedValue = unwrap$1(value);
                  if (this.valueIsObservable(unwrappedValue)) {
                      // When trying to extract the writable version of a readonly we return the readonly.
                      if (this.readOnlyObjectGraph.get(unwrappedValue) === value) {
                          return value;
                      }
                      return this.getReactiveHandler(unwrappedValue);
                  }
                  return unwrappedValue;
              }
          },
          {
              key: "getReadOnlyProxy",
              value: function getReadOnlyProxy(value) {
                  value = unwrap$1(value);
                  if (this.valueIsObservable(value)) {
                      return this.getReadOnlyHandler(value);
                  }
                  return value;
              }
          },
          {
              key: "unwrapProxy",
              value: function unwrapProxy(p) {
                  return unwrap$1(p);
              }
          },
          {
              key: "getReactiveHandler",
              value: function getReactiveHandler(value) {
                  var proxy = this.reactiveObjectGraph.get(value);
                  if (isUndefined(proxy)) {
                      // caching the proxy after the first time it is accessed
                      var handler = new ReactiveProxyHandler(this, value);
                      proxy = new Proxy(createShadowTarget(value), handler);
                      registerProxy(proxy, value);
                      this.reactiveObjectGraph.set(value, proxy);
                  }
                  return proxy;
              }
          },
          {
              key: "getReadOnlyHandler",
              value: function getReadOnlyHandler(value) {
                  var proxy = this.readOnlyObjectGraph.get(value);
                  if (isUndefined(proxy)) {
                      // caching the proxy after the first time it is accessed
                      var handler = new ReadOnlyHandler(this, value);
                      proxy = new Proxy(createShadowTarget(value), handler);
                      registerProxy(proxy, value);
                      this.readOnlyObjectGraph.set(value, proxy);
                  }
                  return proxy;
              }
          }
      ]);
      return ObservableMembrane;
  }();
  /** version: 2.0.0 */ /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var lockerLivePropertyKey = Symbol.for("@@lockerLiveValue");
  var reactiveMembrane = new ObservableMembrane({
      valueObserved: valueObserved,
      valueMutated: valueMutated,
      tagPropertyKey: lockerLivePropertyKey
  });
  /**
   * EXPERIMENTAL: This function implements an unwrap mechanism that
   * works for observable membrane objects. This API is subject to
   * change or being removed.
   */ function unwrap(value) {
      return reactiveMembrane.unwrapProxy(value);
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ /**
   * This operation is called with a descriptor of an standard html property
   * that a Custom Element can support (including AOM properties), which
   * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors
   * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.
   */ function createBridgeToElementDescriptor(propName, descriptor) {
      var get = descriptor.get, set = descriptor.set, enumerable = descriptor.enumerable, configurable = descriptor.configurable;
      if (!isFunction$1(get)) {
          if (process.env.NODE_ENV !== "production") {
              assert.fail("Detected invalid public property descriptor for HTMLElement.prototype.".concat(propName, " definition. Missing the standard getter."));
          }
          throw new TypeError();
      }
      if (!isFunction$1(set)) {
          if (process.env.NODE_ENV !== "production") {
              assert.fail("Detected invalid public property descriptor for HTMLElement.prototype.".concat(propName, " definition. Missing the standard setter."));
          }
          throw new TypeError();
      }
      return {
          enumerable: enumerable,
          configurable: configurable,
          get: function get1() {
              var vm12 = getAssociatedVM(this);
              if (isBeingConstructed(vm12)) {
                  if (process.env.NODE_ENV !== "production") {
                      logError("The value of property `".concat(propName, "` can't be read from the constructor because the owner component hasn't set the value yet. Instead, use the constructor to set a default value for the property."), vm12);
                  }
                  return;
              }
              componentValueObserved(vm12, propName);
              return get.call(vm12.elm);
          },
          set: function set1(newValue) {
              var vm13 = getAssociatedVM(this);
              if (process.env.NODE_ENV !== "production") {
                  var vmBeingRendered1 = getVMBeingRendered();
                  assert.invariant(!isInvokingRender, "".concat(vmBeingRendered1, ".render() method has side effects on the state of ").concat(vm13, ".").concat(propName));
                  assert.invariant(!isUpdatingTemplate, "When updating the template of ".concat(vmBeingRendered1, ", one of the accessors used by the template has side effects on the state of ").concat(vm13, ".").concat(propName));
                  assert.isFalse(isBeingConstructed(vm13), "Failed to construct '".concat(getComponentTag(vm13), "': The result must not have attributes."));
                  assert.invariant(!isObject(newValue) || isNull(newValue), 'Invalid value "'.concat(newValue, '" for "').concat(propName, '" of ').concat(vm13, ". Value cannot be an object, must be a primitive value."));
              }
              if (newValue !== vm13.cmpProps[propName]) {
                  vm13.cmpProps[propName] = newValue;
                  componentValueMutated(vm13, propName);
              }
              return set.call(vm13.elm, newValue);
          }
      };
  }
  /**
   * This class is the base class for any LWC element.
   * Some elements directly extends this class, others implement it via inheritance.
   **/ // @ts-ignore
  var LightningElement = function LightningElement() {
      // This should be as performant as possible, while any initialization should be done lazily
      if (isNull(vmBeingConstructed)) {
          throw new ReferenceError("Illegal constructor");
      }
      var vm14 = vmBeingConstructed;
      var def = vm14.def, elm8 = vm14.elm;
      var bridge = def.bridge;
      if (process.env.NODE_ENV !== "production") {
          assertInstanceOfHTMLElement$1(vm14.elm, "Component creation requires a DOM element to be associated to ".concat(vm14, "."));
      }
      var component = this;
      setPrototypeOf(elm8, bridge.prototype);
      vm14.component = this;
      // Locker hooks assignment. When the LWC engine run with Locker, Locker intercepts all the new
      // component creation and passes hooks to instrument all the component interactions with the
      // engine. We are intentionally hiding this argument from the formal API of LightningElement
      // because we don't want folks to know about it just yet.
      if (arguments.length === 1) {
          var ref10 = arguments[0], callHook1 = ref10.callHook, setHook1 = ref10.setHook, getHook1 = ref10.getHook;
          vm14.callHook = callHook1;
          vm14.setHook = setHook1;
          vm14.getHook = getHook1;
      }
      // Making the component instance a live value when using Locker to support expandos.
      this[lockerLivePropertyKey] = undefined;
      // Linking elm, shadow root and component with the VM.
      associateVM(component, vm14);
      associateVM(elm8, vm14);
      if (vm14.renderMode === 1 /* Shadow */ ) {
          vm14.renderRoot = doAttachShadow(vm14);
      } else {
          vm14.renderRoot = elm8;
      }
      // Adding extra guard rails in DEV mode.
      if (process.env.NODE_ENV !== "production") {
          patchCustomElementWithRestrictions(elm8);
          patchComponentWithRestrictions(component);
      }
      return this;
  };
  function doAttachShadow(vm15) {
      var elm9 = vm15.elm, mode = vm15.mode, shadowMode = vm15.shadowMode, ctor = vm15.def.ctor;
      var _obj;
      var shadowRoot = attachShadow$1(elm9, (_obj = {}, _defineProperty(_obj, KEY__SYNTHETIC_MODE, shadowMode === 1 /* Synthetic */ ), _defineProperty(_obj, "delegatesFocus", Boolean(ctor.delegatesFocus)), _defineProperty(_obj, "mode", mode), _obj));
      vm15.shadowRoot = shadowRoot;
      associateVM(shadowRoot, vm15);
      if (process.env.NODE_ENV !== "production") {
          patchShadowRootWithRestrictions(shadowRoot);
      }
      return shadowRoot;
  }
  function warnIfInvokedDuringConstruction(vm16, methodOrPropName) {
      if (isBeingConstructed(vm16)) {
          logError("this.".concat(methodOrPropName, " should not be called during the construction of the custom element for ").concat(getComponentTag(vm16), " because the element is not yet in the DOM or has no children yet."));
      }
  }
  // @ts-ignore
  LightningElement.prototype = {
      constructor: LightningElement,
      dispatchEvent: function dispatchEvent(event) {
          var elm10 = getAssociatedVM(this).elm;
          return dispatchEvent$1(elm10, event);
      },
      addEventListener: function addEventListener(type, listener, options) {
          var vm17 = getAssociatedVM(this);
          var elm11 = vm17.elm;
          if (process.env.NODE_ENV !== "production") {
              var vmBeingRendered2 = getVMBeingRendered();
              assert.invariant(!isInvokingRender, "".concat(vmBeingRendered2, ".render() method has side effects on the state of ").concat(vm17, ' by adding an event listener for "').concat(type, '".'));
              assert.invariant(!isUpdatingTemplate, "Updating the template of ".concat(vmBeingRendered2, " has side effects on the state of ").concat(vm17, ' by adding an event listener for "').concat(type, '".'));
              assert.invariant(isFunction$1(listener), "Invalid second argument for this.addEventListener() in ".concat(vm17, ' for event "').concat(type, '". Expected an EventListener but received ').concat(listener, "."));
          }
          var wrappedListener = getWrappedComponentsListener(vm17, listener);
          addEventListener$1(elm11, type, wrappedListener, options);
      },
      removeEventListener: function removeEventListener(type, listener, options) {
          var vm18 = getAssociatedVM(this);
          var elm12 = vm18.elm;
          var wrappedListener = getWrappedComponentsListener(vm18, listener);
          removeEventListener$1(elm12, type, wrappedListener, options);
      },
      hasAttribute: function hasAttribute(name) {
          var elm13 = getAssociatedVM(this).elm;
          return !isNull(getAttribute$1(elm13, name));
      },
      hasAttributeNS: function hasAttributeNS(namespace, name) {
          var elm14 = getAssociatedVM(this).elm;
          return !isNull(getAttribute$1(elm14, name, namespace));
      },
      removeAttribute: function removeAttribute(name) {
          var elm15 = getAssociatedVM(this).elm;
          unlockAttribute(elm15, name);
          removeAttribute$1(elm15, name);
          lockAttribute();
      },
      removeAttributeNS: function removeAttributeNS(namespace, name) {
          var elm16 = getAssociatedVM(this).elm;
          unlockAttribute(elm16, name);
          removeAttribute$1(elm16, name, namespace);
          lockAttribute();
      },
      getAttribute: function getAttribute(name) {
          var elm17 = getAssociatedVM(this).elm;
          return getAttribute$1(elm17, name);
      },
      getAttributeNS: function getAttributeNS(namespace, name) {
          var elm18 = getAssociatedVM(this).elm;
          return getAttribute$1(elm18, name, namespace);
      },
      setAttribute: function setAttribute(name, value) {
          var vm19 = getAssociatedVM(this);
          var elm19 = vm19.elm;
          if (process.env.NODE_ENV !== "production") {
              assert.isFalse(isBeingConstructed(vm19), "Failed to construct '".concat(getComponentTag(vm19), "': The result must not have attributes."));
          }
          unlockAttribute(elm19, name);
          setAttribute$1(elm19, name, value);
          lockAttribute();
      },
      setAttributeNS: function setAttributeNS(namespace, name, value) {
          var vm20 = getAssociatedVM(this);
          var elm20 = vm20.elm;
          if (process.env.NODE_ENV !== "production") {
              assert.isFalse(isBeingConstructed(vm20), "Failed to construct '".concat(getComponentTag(vm20), "': The result must not have attributes."));
          }
          unlockAttribute(elm20, name);
          setAttribute$1(elm20, name, value, namespace);
          lockAttribute();
      },
      getBoundingClientRect: function getBoundingClientRect() {
          var vm21 = getAssociatedVM(this);
          var elm21 = vm21.elm;
          if (process.env.NODE_ENV !== "production") {
              warnIfInvokedDuringConstruction(vm21, "getBoundingClientRect()");
          }
          return getBoundingClientRect$1(elm21);
      },
      get isConnected () {
          var elm = getAssociatedVM(this).elm;
          return isConnected$1(elm);
      },
      get classList () {
          var vm = getAssociatedVM(this);
          var elm1 = vm.elm;
          if (process.env.NODE_ENV !== "production") {
              // TODO [#1290]: this still fails in dev but works in production, eventually, we should
              // just throw in all modes
              assert.isFalse(isBeingConstructed(vm), "Failed to construct ".concat(vm, ": The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead."));
          }
          return getClassList$1(elm1);
      },
      get template () {
          var vm1 = getAssociatedVM(this);
          if (process.env.NODE_ENV !== "production") {
              if (vm1.renderMode === 0 /* Light */ ) {
                  logError("`this.template` returns null for light DOM components. Since there is no shadow, the rendered content can be accessed via `this` itself. e.g. instead of `this.template.querySelector`, use `this.querySelector`.");
              }
          }
          return vm1.shadowRoot;
      },
      get shadowRoot () {
          // From within the component instance, the shadowRoot is always reported as "closed".
          // Authors should rely on this.template instead.
          return null;
      },
      render: function render() {
          var vm = getAssociatedVM(this);
          return vm.def.template;
      },
      toString: function toString() {
          var vm = getAssociatedVM(this);
          return "[object ".concat(vm.def.name, "]");
      }
  };
  var queryAndChildGetterDescriptors = create(null);
  // The reason we don't just call `import * as renderer from '../renderer'` here is that the bundle size
  // is smaller if we reference each function individually. Otherwise Rollup will create one big frozen
  // object representing the renderer, with a lot of methods we don't actually need.
  var childGetters = [
      "children",
      "childNodes",
      "firstChild",
      "firstElementChild",
      "lastChild",
      "lastElementChild", 
  ];
  function getChildGetter(methodName) {
      switch(methodName){
          case "children":
              return getChildren$1;
          case "childNodes":
              return getChildNodes$1;
          case "firstChild":
              return getFirstChild$1;
          case "firstElementChild":
              return getFirstElementChild$1;
          case "lastChild":
              return getLastChild$1;
          case "lastElementChild":
              return getLastElementChild$1;
      }
  }
  var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
  try {
      var _loop = function(_iterator, _step) {
          var childGetter = _step.value;
          queryAndChildGetterDescriptors[childGetter] = {
              get: function get1() {
                  var vm = getAssociatedVM(this);
                  var elm = vm.elm;
                  if (process.env.NODE_ENV !== "production") {
                      warnIfInvokedDuringConstruction(vm, childGetter);
                  }
                  return getChildGetter(childGetter)(elm);
              },
              configurable: true,
              enumerable: true
          };
      };
      // Generic passthrough for child getters on HTMLElement to the relevant Renderer APIs
      for(var _iterator = childGetters[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop(_iterator, _step);
  } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
  } finally{
      try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
          }
      } finally{
          if (_didIteratorError) {
              throw _iteratorError;
          }
      }
  }
  var queryMethods = [
      "getElementsByClassName",
      "getElementsByTagName",
      "querySelector",
      "querySelectorAll", 
  ];
  function getQueryMethod(methodName) {
      switch(methodName){
          case "getElementsByClassName":
              return getElementsByClassName$1;
          case "getElementsByTagName":
              return getElementsByTagName$1;
          case "querySelector":
              return querySelector$1;
          case "querySelectorAll":
              return querySelectorAll$1;
      }
  }
  var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
  try {
      var _loop1 = function(_iterator1, _step1) {
          var queryMethod = _step1.value;
          queryAndChildGetterDescriptors[queryMethod] = {
              value: function value(arg) {
                  var vm = getAssociatedVM(this);
                  var elm = vm.elm;
                  if (process.env.NODE_ENV !== "production") {
                      warnIfInvokedDuringConstruction(vm, "".concat(queryMethod, "()"));
                  }
                  return getQueryMethod(queryMethod)(elm, arg);
              },
              configurable: true,
              enumerable: true,
              writable: true
          };
      };
      // Generic passthrough for query APIs on HTMLElement to the relevant Renderer APIs
      for(var _iterator1 = queryMethods[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true)_loop1(_iterator1, _step1);
  } catch (err) {
      _didIteratorError1 = true;
      _iteratorError1 = err;
  } finally{
      try {
          if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
              _iterator1.return();
          }
      } finally{
          if (_didIteratorError1) {
              throw _iteratorError1;
          }
      }
  }
  defineProperties(LightningElement.prototype, queryAndChildGetterDescriptors);
  var lightningBasedDescriptors = create(null);
  for(var propName1 in HTMLElementOriginalDescriptors){
      lightningBasedDescriptors[propName1] = createBridgeToElementDescriptor(propName1, HTMLElementOriginalDescriptors[propName1]);
  }
  defineProperties(LightningElement.prototype, lightningBasedDescriptors);
  defineProperty(LightningElement, "CustomElementConstructor", {
      get: function get1() {
          // If required, a runtime-specific implementation must be defined.
          throw new ReferenceError("The current runtime does not support CustomElementConstructor.");
      },
      configurable: true
  });
  if (process.env.NODE_ENV !== "production") {
      patchLightningElementPrototypeWithRestrictions(LightningElement.prototype);
  }
  function createObservedFieldPropertyDescriptor(key) {
      return {
          get: function get1() {
              var vm = getAssociatedVM(this);
              componentValueObserved(vm, key);
              return vm.cmpFields[key];
          },
          set: function set1(newValue) {
              var vm = getAssociatedVM(this);
              if (newValue !== vm.cmpFields[key]) {
                  vm.cmpFields[key] = newValue;
                  componentValueMutated(vm, key);
              }
          },
          enumerable: true,
          configurable: true
      };
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function api$1() {
      if (process.env.NODE_ENV !== "production") {
          assert.fail("@api decorator can only be used as a decorator function.");
      }
      throw new Error();
  }
  function createPublicPropertyDescriptor(key) {
      return {
          get: function get1() {
              var vm = getAssociatedVM(this);
              if (isBeingConstructed(vm)) {
                  if (process.env.NODE_ENV !== "production") {
                      logError("Can\u2019t read the value of property `".concat(toString$1(key), "` from the constructor because the owner component hasn\u2019t set the value yet. Instead, use the constructor to set a default value for the property."), vm);
                  }
                  return;
              }
              componentValueObserved(vm, key);
              return vm.cmpProps[key];
          },
          set: function set1(newValue) {
              var vm = getAssociatedVM(this);
              if (process.env.NODE_ENV !== "production") {
                  var vmBeingRendered3 = getVMBeingRendered();
                  assert.invariant(!isInvokingRender, "".concat(vmBeingRendered3, ".render() method has side effects on the state of ").concat(vm, ".").concat(toString$1(key)));
                  assert.invariant(!isUpdatingTemplate, "Updating the template of ".concat(vmBeingRendered3, " has side effects on the state of ").concat(vm, ".").concat(toString$1(key)));
              }
              vm.cmpProps[key] = newValue;
              componentValueMutated(vm, key);
          },
          enumerable: true,
          configurable: true
      };
  }
  var AccessorReactiveObserver = /*#__PURE__*/ function(ReactiveObserver) {
      _inherits(AccessorReactiveObserver, ReactiveObserver);
      var _super = _createSuper(AccessorReactiveObserver);
      function AccessorReactiveObserver(vm, set) {
          _classCallCheck(this, AccessorReactiveObserver);
          var _this;
          _this = _super.call(this, function() {
              if (isFalse(_this.debouncing)) {
                  _this.debouncing = true;
                  addCallbackToNextTick(function() {
                      if (isTrue(_this.debouncing)) {
                          var value = _assertThisInitialized(_this).value;
                          var dirtyStateBeforeSetterCall = vm.isDirty, component = vm.component, idx1 = vm.idx;
                          set.call(component, value); // de-bouncing after the call to the original setter to prevent
                          // infinity loop if the setter itself is mutating things that
                          // were accessed during the previous invocation.
                          _this.debouncing = false;
                          if (isTrue(vm.isDirty) && isFalse(dirtyStateBeforeSetterCall) && idx1 > 0) {
                              // immediate rehydration due to a setter driven mutation, otherwise
                              // the component will get rendered on the second tick, which it is not
                              // desirable.
                              rerenderVM(vm);
                          }
                      }
                  });
              }
          });
          _this.debouncing = false;
          return _this;
      }
      _createClass(AccessorReactiveObserver, [
          {
              key: "reset",
              value: function reset(value) {
                  _get(_getPrototypeOf(AccessorReactiveObserver.prototype), "reset", this).call(this);
                  this.debouncing = false;
                  if (arguments.length > 0) {
                      this.value = value;
                  }
              }
          }
      ]);
      return AccessorReactiveObserver;
  }(ReactiveObserver);
  function createPublicAccessorDescriptor(key, descriptor) {
      var get = descriptor.get, set = descriptor.set, enumerable = descriptor.enumerable, configurable = descriptor.configurable;
      if (!isFunction$1(get)) {
          if (process.env.NODE_ENV !== "production") {
              assert.invariant(isFunction$1(get), "Invalid compiler output for public accessor ".concat(toString$1(key), " decorated with @api"));
          }
          throw new Error();
      }
      return {
          get: function get1() {
              if (process.env.NODE_ENV !== "production") {
                  // Assert that the this value is an actual Component with an associated VM.
                  getAssociatedVM(this);
              }
              return get.call(this);
          },
          set: function set1(newValue) {
              var vm = getAssociatedVM(this);
              if (process.env.NODE_ENV !== "production") {
                  var vmBeingRendered4 = getVMBeingRendered();
                  assert.invariant(!isInvokingRender, "".concat(vmBeingRendered4, ".render() method has side effects on the state of ").concat(vm, ".").concat(toString$1(key)));
                  assert.invariant(!isUpdatingTemplate, "Updating the template of ".concat(vmBeingRendered4, " has side effects on the state of ").concat(vm, ".").concat(toString$1(key)));
              }
              if (set) {
                  if (runtimeFlags.ENABLE_REACTIVE_SETTER) {
                      var _this = this;
                      var ro = vm.oar[key];
                      if (isUndefined$1(ro)) {
                          ro = vm.oar[key] = new AccessorReactiveObserver(vm, set);
                      } // every time we invoke this setter from outside (through this wrapper setter)
                      // we should reset the value and then debounce just in case there is a pending
                      // invocation the next tick that is not longer relevant since the value is changing
                      // from outside.
                      ro.reset(newValue);
                      ro.observe(function() {
                          set.call(_this, newValue);
                      });
                  } else {
                      set.call(this, newValue);
                  }
              } else if (process.env.NODE_ENV !== "production") {
                  assert.fail("Invalid attempt to set a new value for property ".concat(toString$1(key), " of ").concat(vm, " that does not has a setter decorated with @api."));
              }
          },
          enumerable: enumerable,
          configurable: configurable
      };
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function track(target) {
      if (arguments.length === 1) {
          return reactiveMembrane.getProxy(target);
      }
      if (process.env.NODE_ENV !== "production") {
          assert.fail("@track decorator can only be used with one argument to return a trackable object, or as a decorator function.");
      }
      throw new Error();
  }
  function internalTrackDecorator(key) {
      return {
          get: function get1() {
              var vm = getAssociatedVM(this);
              componentValueObserved(vm, key);
              return vm.cmpFields[key];
          },
          set: function set1(newValue) {
              var vm = getAssociatedVM(this);
              if (process.env.NODE_ENV !== "production") {
                  var vmBeingRendered5 = getVMBeingRendered();
                  assert.invariant(!isInvokingRender, "".concat(vmBeingRendered5, ".render() method has side effects on the state of ").concat(vm, ".").concat(toString$1(key)));
                  assert.invariant(!isUpdatingTemplate, "Updating the template of ".concat(vmBeingRendered5, " has side effects on the state of ").concat(vm, ".").concat(toString$1(key)));
              }
              var reactiveOrAnyValue = reactiveMembrane.getProxy(newValue);
              if (reactiveOrAnyValue !== vm.cmpFields[key]) {
                  vm.cmpFields[key] = reactiveOrAnyValue;
                  componentValueMutated(vm, key);
              }
          },
          enumerable: true,
          configurable: true
      };
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ /**
   * @wire decorator to wire fields and methods to a wire adapter in
   * LWC Components. This function implements the internals of this
   * decorator.
   */ function wire(_adapter, _config) {
      if (process.env.NODE_ENV !== "production") {
          assert.fail("@wire(adapter, config?) may only be used as a decorator.");
      }
      throw new Error();
  }
  function internalWireFieldDecorator(key) {
      return {
          get: function get1() {
              var vm = getAssociatedVM(this);
              componentValueObserved(vm, key);
              return vm.cmpFields[key];
          },
          set: function set1(value) {
              var vm = getAssociatedVM(this);
              /**
               * Reactivity for wired fields is provided in wiring.
               * We intentionally add reactivity here since this is just
               * letting the author to do the wrong thing, but it will keep our
               * system to be backward compatible.
               */ if (value !== vm.cmpFields[key]) {
                  vm.cmpFields[key] = value;
                  componentValueMutated(vm, key);
              }
          },
          enumerable: true,
          configurable: true
      };
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function getClassDescriptorType(descriptor) {
      if (isFunction$1(descriptor.value)) {
          return "method" /* Method */ ;
      } else if (isFunction$1(descriptor.set) || isFunction$1(descriptor.get)) {
          return "accessor" /* Accessor */ ;
      } else {
          return "field" /* Field */ ;
      }
  }
  function validateObservedField(Ctor, fieldName, descriptor) {
      if (!isUndefined$1(descriptor)) {
          var type = getClassDescriptorType(descriptor);
          var message = "Invalid observed ".concat(fieldName, " field. Found a duplicate ").concat(type, " with the same name.");
          // [W-9927596] Ideally we always throw an error when detecting duplicate observed field.
          // This branch is only here for backward compatibility reasons.
          if (type === "accessor" /* Accessor */ ) {
              logError(message);
          } else {
              assert.fail(message);
          }
      }
  }
  function validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor) {
      if (!isUndefined$1(descriptor)) {
          var type = getClassDescriptorType(descriptor);
          assert.fail("Invalid @track ".concat(fieldName, " field. Found a duplicate ").concat(type, " with the same name."));
      }
  }
  function validateFieldDecoratedWithWire(Ctor, fieldName, descriptor) {
      if (!isUndefined$1(descriptor)) {
          var type = getClassDescriptorType(descriptor);
          assert.fail("Invalid @wire ".concat(fieldName, " field. Found a duplicate ").concat(type, " with the same name."));
      }
  }
  function validateMethodDecoratedWithWire(Ctor, methodName, descriptor) {
      if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse(descriptor.writable)) {
          assert.fail("Invalid @wire ".concat(methodName, " method."));
      }
  }
  function validateFieldDecoratedWithApi(Ctor, fieldName, descriptor) {
      if (!isUndefined$1(descriptor)) {
          var type = getClassDescriptorType(descriptor);
          var message = "Invalid @api ".concat(fieldName, " field. Found a duplicate ").concat(type, " with the same name.");
          // [W-9927596] Ideally we always throw an error when detecting duplicate public properties.
          // This branch is only here for backward compatibility reasons.
          if (type === "accessor" /* Accessor */ ) {
              logError(message);
          } else {
              assert.fail(message);
          }
      }
  }
  function validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor) {
      if (isUndefined$1(descriptor)) {
          assert.fail("Invalid @api get ".concat(fieldName, " accessor."));
      } else if (isFunction$1(descriptor.set)) {
          assert.isTrue(isFunction$1(descriptor.get), "Missing getter for property ".concat(fieldName, " decorated with @api in ").concat(Ctor, ". You cannot have a setter without the corresponding getter."));
      } else if (!isFunction$1(descriptor.get)) {
          assert.fail("Missing @api get ".concat(fieldName, " accessor."));
      }
  }
  function validateMethodDecoratedWithApi(Ctor, methodName, descriptor) {
      if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse(descriptor.writable)) {
          assert.fail("Invalid @api ".concat(methodName, " method."));
      }
  }
  /**
   * INTERNAL: This function can only be invoked by compiled code. The compiler
   * will prevent this function from being imported by user-land code.
   */ function registerDecorators(Ctor, meta) {
      var proto = Ctor.prototype;
      var publicProps = meta.publicProps, publicMethods = meta.publicMethods, wire1 = meta.wire, track1 = meta.track, fields = meta.fields;
      var apiMethods = create(null);
      var apiFields = create(null);
      var wiredMethods = create(null);
      var wiredFields = create(null);
      var observedFields = create(null);
      var apiFieldsConfig = create(null);
      var descriptor;
      if (!isUndefined$1(publicProps)) {
          for(var fieldName in publicProps){
              var propConfig = publicProps[fieldName];
              apiFieldsConfig[fieldName] = propConfig.config;
              descriptor = getOwnPropertyDescriptor$1(proto, fieldName);
              if (propConfig.config > 0) {
                  // accessor declaration
                  if (process.env.NODE_ENV !== "production") {
                      validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor);
                  }
                  if (isUndefined$1(descriptor)) {
                      throw new Error();
                  }
                  descriptor = createPublicAccessorDescriptor(fieldName, descriptor);
              } else {
                  // field declaration
                  if (process.env.NODE_ENV !== "production") {
                      validateFieldDecoratedWithApi(Ctor, fieldName, descriptor);
                  }
                  // [W-9927596] If a component has both a public property and a private setter/getter
                  // with the same name, the property is defined as a public accessor. This branch is
                  // only here for backward compatibility reasons.
                  if (!isUndefined$1(descriptor) && !isUndefined$1(descriptor.get)) {
                      descriptor = createPublicAccessorDescriptor(fieldName, descriptor);
                  } else {
                      descriptor = createPublicPropertyDescriptor(fieldName);
                  }
              }
              apiFields[fieldName] = descriptor;
              defineProperty(proto, fieldName, descriptor);
          }
      }
      if (!isUndefined$1(publicMethods)) {
          forEach.call(publicMethods, function(methodName) {
              descriptor = getOwnPropertyDescriptor$1(proto, methodName);
              if (process.env.NODE_ENV !== "production") {
                  validateMethodDecoratedWithApi(Ctor, methodName, descriptor);
              }
              if (isUndefined$1(descriptor)) {
                  throw new Error();
              }
              apiMethods[methodName] = descriptor;
          });
      }
      if (!isUndefined$1(wire1)) {
          for(var fieldOrMethodName in wire1){
              var _fieldOrMethodName = wire1[fieldOrMethodName], adapter = _fieldOrMethodName.adapter, method = _fieldOrMethodName.method, configCallback = _fieldOrMethodName.config, _dynamic = _fieldOrMethodName.dynamic, dynamic = _dynamic === void 0 ? [] : _dynamic;
              descriptor = getOwnPropertyDescriptor$1(proto, fieldOrMethodName);
              if (method === 1) {
                  if (process.env.NODE_ENV !== "production") {
                      assert.isTrue(adapter, '@wire on method "'.concat(fieldOrMethodName, '": adapter id must be truthy.'));
                      validateMethodDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);
                  }
                  if (isUndefined$1(descriptor)) {
                      throw new Error();
                  }
                  wiredMethods[fieldOrMethodName] = descriptor;
                  storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic);
              } else {
                  if (process.env.NODE_ENV !== "production") {
                      assert.isTrue(adapter, '@wire on field "'.concat(fieldOrMethodName, '": adapter id must be truthy.'));
                      validateFieldDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);
                  }
                  descriptor = internalWireFieldDecorator(fieldOrMethodName);
                  wiredFields[fieldOrMethodName] = descriptor;
                  storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic);
                  defineProperty(proto, fieldOrMethodName, descriptor);
              }
          }
      }
      if (!isUndefined$1(track1)) {
          for(var fieldName1 in track1){
              descriptor = getOwnPropertyDescriptor$1(proto, fieldName1);
              if (process.env.NODE_ENV !== "production") {
                  validateFieldDecoratedWithTrack(Ctor, fieldName1, descriptor);
              }
              descriptor = internalTrackDecorator(fieldName1);
              defineProperty(proto, fieldName1, descriptor);
          }
      }
      if (!isUndefined$1(fields)) {
          for(var _$i5 = 0, n = fields.length; _$i5 < n; _$i5++){
              var fieldName2 = fields[_$i5];
              descriptor = getOwnPropertyDescriptor$1(proto, fieldName2);
              if (process.env.NODE_ENV !== "production") {
                  validateObservedField(Ctor, fieldName2, descriptor);
              }
              // [W-9927596] Only mark a field as observed whenever it isn't a duplicated public nor
              // tracked property. This is only here for backward compatibility purposes.
              var isDuplicatePublicProp = !isUndefined$1(publicProps) && fieldName2 in publicProps;
              var isDuplicateTrackedProp = !isUndefined$1(track1) && fieldName2 in track1;
              if (!isDuplicatePublicProp && !isDuplicateTrackedProp) {
                  observedFields[fieldName2] = createObservedFieldPropertyDescriptor(fieldName2);
              }
          }
      }
      setDecoratorsMeta(Ctor, {
          apiMethods: apiMethods,
          apiFields: apiFields,
          apiFieldsConfig: apiFieldsConfig,
          wiredMethods: wiredMethods,
          wiredFields: wiredFields,
          observedFields: observedFields
      });
      return Ctor;
  }
  var signedDecoratorToMetaMap = new Map();
  function setDecoratorsMeta(Ctor, meta) {
      signedDecoratorToMetaMap.set(Ctor, meta);
  }
  var defaultMeta = {
      apiMethods: EmptyObject,
      apiFields: EmptyObject,
      apiFieldsConfig: EmptyObject,
      wiredMethods: EmptyObject,
      wiredFields: EmptyObject,
      observedFields: EmptyObject
  };
  function getDecoratorsMeta(Ctor) {
      var meta = signedDecoratorToMetaMap.get(Ctor);
      return isUndefined$1(meta) ? defaultMeta : meta;
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var warned = false;
  if (process.env.NODE_ENV === "development") {
      // @ts-ignore
      window.__lwcResetWarnedOnVersionMismatch = function() {
          warned = false;
      };
  }
  function checkVersionMismatch(func, type) {
      var versionMatcher = func.toString().match(LWC_VERSION_COMMENT_REGEX);
      if (!isNull(versionMatcher) && !warned) {
          var version = versionMatcher[1];
          var ref12 = _slicedToArray(version.split("."), 2), major = ref12[0], minor = ref12[1];
          var ref11 = _slicedToArray(LWC_VERSION.split("."), 2), expectedMajor = ref11[0], expectedMinor = ref11[1];
          if (major !== expectedMajor || minor !== expectedMinor) {
              warned = true; // only warn once to avoid flooding the console
              // stylesheets and templates do not have user-meaningful names, but components do
              var friendlyName = type === "component" ? "".concat(type, " ").concat(func.name) : type;
              logError("LWC WARNING: current engine is v".concat(LWC_VERSION, ", but ").concat(friendlyName, " was compiled with v").concat(version, ".\nPlease update your compiled code or LWC engine so that the versions match.\nNo further warnings will appear."));
          }
      }
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var signedTemplateSet = new Set();
  function defaultEmptyTemplate() {
      return [];
  }
  signedTemplateSet.add(defaultEmptyTemplate);
  function isTemplateRegistered(tpl) {
      return signedTemplateSet.has(tpl);
  }
  /**
   * INTERNAL: This function can only be invoked by compiled code. The compiler
   * will prevent this function from being imported by userland code.
   */ function registerTemplate(tpl) {
      if (process.env.NODE_ENV !== "production") {
          checkVersionMismatch(tpl, "template");
      }
      signedTemplateSet.add(tpl);
      // FIXME[@W-10950976]: the template object should be frozen, and it should not be possible to set
      // the stylesheets or stylesheetToken(s). For backwards compat, though, we shim stylesheetTokens
      // on top of stylesheetToken for anyone who is accessing the old internal API.
      // Details: https://salesforce.quip.com/v1rmAFu2cKAr
      defineProperty(tpl, "stylesheetTokens", {
          get: function get1() {
              var stylesheetToken = this.stylesheetToken;
              if (isUndefined$1(stylesheetToken)) {
                  return stylesheetToken;
              }
              // Shim for the old `stylesheetTokens` property
              // See https://github.com/salesforce/lwc/pull/2332/files#diff-7901555acef29969adaa6583185b3e9bce475cdc6f23e799a54e0018cb18abaa
              return {
                  hostAttribute: "".concat(stylesheetToken, "-host"),
                  shadowAttribute: stylesheetToken
              };
          },
          set: function set1(value) {
              // If the value is null or some other exotic object, you would be broken anyway in the past
              // because the engine would try to access hostAttribute/shadowAttribute, which would throw an error.
              // However it may be undefined in newer versions of LWC, so we need to guard against that case.
              this.stylesheetToken = isUndefined$1(value) ? undefined : value.shadowAttribute;
          }
      });
      // chaining this method as a way to wrap existing
      // assignment of templates easily, without too much transformation
      return tpl;
  }
  /**
   * EXPERIMENTAL: This function acts like a hook for Lightning Locker Service and other similar
   * libraries to sanitize vulnerable attributes.
   */ function sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {
      // locker-service patches this function during runtime to sanitize vulnerable attributes. When
      // ran off-core this function becomes a noop and returns the user authored value.
      return attrValue;
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ // A bridge descriptor is a descriptor whose job is just to get the component instance
  // from the element instance, and get the value or set a new value on the component.
  // This means that across different elements, similar names can get the exact same
  // descriptor, so we can cache them:
  var cachedGetterByKey = create(null);
  var cachedSetterByKey = create(null);
  function createGetter(key) {
      var fn = cachedGetterByKey[key];
      if (isUndefined$1(fn)) {
          fn = cachedGetterByKey[key] = function fn() {
              var vm = getAssociatedVM(this);
              var getHook2 = vm.getHook;
              return getHook2(vm.component, key);
          };
      }
      return fn;
  }
  function createSetter(key) {
      var fn = cachedSetterByKey[key];
      if (isUndefined$1(fn)) {
          fn = cachedSetterByKey[key] = function fn(newValue) {
              var vm = getAssociatedVM(this);
              var setHook2 = vm.setHook;
              newValue = reactiveMembrane.getReadOnlyProxy(newValue);
              setHook2(vm.component, key, newValue);
          };
      }
      return fn;
  }
  function createMethodCaller(methodName) {
      return function() {
          var vm = getAssociatedVM(this);
          var callHook2 = vm.callHook, component = vm.component;
          var fn = component[methodName];
          return callHook2(vm.component, fn, ArraySlice.call(arguments));
      };
  }
  function createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback) {
      return function attributeChangedCallback(attrName, oldValue, newValue) {
          if (oldValue === newValue) {
              // Ignore same values.
              return;
          }
          var propName = attributeToPropMap[attrName];
          if (isUndefined$1(propName)) {
              if (!isUndefined$1(superAttributeChangedCallback)) {
                  // delegate unknown attributes to the super.
                  // Typescript does not like it when you treat the `arguments` object as an array
                  // @ts-ignore type-mismatch
                  superAttributeChangedCallback.apply(this, arguments);
              }
              return;
          }
          if (!isAttributeLocked(this, attrName)) {
              // Ignore changes triggered by the engine itself during:
              // * diffing when public props are attempting to reflect to the DOM
              // * component via `this.setAttribute()`, should never update the prop
              // Both cases, the setAttribute call is always wrapped by the unlocking of the
              // attribute to be changed
              return;
          }
          // Reflect attribute change to the corresponding property when changed from outside.
          this[propName] = newValue;
      };
  }
  function HTMLBridgeElementFactory(SuperClass1, props, methods) {
      var HTMLBridgeElement;
      /**
       * Modern browsers will have all Native Constructors as regular Classes
       * and must be instantiated with the new keyword. In older browsers,
       * specifically IE11, those are objects with a prototype property defined,
       * since they are not supposed to be extended or instantiated with the
       * new keyword. This forking logic supports both cases, specifically because
       * wc.ts relies on the construction path of the bridges to create new
       * fully qualifying web components.
       */ if (isFunction$1(SuperClass1)) {
          HTMLBridgeElement = /*#__PURE__*/ function(SuperClass) {
              _inherits(_class, SuperClass);
              var _super = _createSuper(_class);
              function _class() {
                  _classCallCheck(this, _class);
                  return _super.apply(this, arguments);
              }
              return _class;
          }(SuperClass1);
      } else {
          HTMLBridgeElement = function HTMLBridgeElement() {
              // Bridge classes are not supposed to be instantiated directly in
              // browsers that do not support web components.
              throw new TypeError("Illegal constructor");
          };
          // prototype inheritance dance
          setPrototypeOf(HTMLBridgeElement, SuperClass1);
          setPrototypeOf(HTMLBridgeElement.prototype, SuperClass1.prototype);
          defineProperty(HTMLBridgeElement.prototype, "constructor", {
              writable: true,
              configurable: true,
              value: HTMLBridgeElement
          });
      }
      // generating the hash table for attributes to avoid duplicate fields and facilitate validation
      // and false positives in case of inheritance.
      var attributeToPropMap = create(null);
      var _prototype4 = SuperClass1.prototype, superAttributeChangedCallback = _prototype4.attributeChangedCallback;
      var tmp = SuperClass1.observedAttributes, superObservedAttributes = tmp === void 0 ? [] : tmp;
      var descriptors = create(null);
      // expose getters and setters for each public props on the new Element Bridge
      for(var _$i7 = 0, len7 = props.length; _$i7 < len7; _$i7 += 1){
          var propName = props[_$i7];
          attributeToPropMap[htmlPropertyToAttribute(propName)] = propName;
          descriptors[propName] = {
              get: createGetter(propName),
              set: createSetter(propName),
              enumerable: true,
              configurable: true
          };
      }
      // expose public methods as props on the new Element Bridge
      for(var _$i6 = 0, len6 = methods.length; _$i6 < len6; _$i6 += 1){
          var methodName = methods[_$i6];
          descriptors[methodName] = {
              value: createMethodCaller(methodName),
              writable: true,
              configurable: true
          };
      }
      // creating a new attributeChangedCallback per bridge because they are bound to the corresponding
      // map of attributes to props. We do this after all other props and methods to avoid the possibility
      // of getting overrule by a class declaration in user-land, and we make it non-writable, non-configurable
      // to preserve this definition.
      descriptors.attributeChangedCallback = {
          value: createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback)
      };
      // Specify attributes for which we want to reflect changes back to their corresponding
      // properties via attributeChangedCallback.
      defineProperty(HTMLBridgeElement, "observedAttributes", {
          get: function get1() {
              return _toConsumableArray(superObservedAttributes).concat(_toConsumableArray(keys(attributeToPropMap)));
          }
      });
      defineProperties(HTMLBridgeElement.prototype, descriptors);
      return HTMLBridgeElement;
  }
  var BaseBridgeElement = HTMLBridgeElementFactory(HTMLElementConstructor$1, getOwnPropertyNames$1(HTMLElementOriginalDescriptors), []);
  freeze(BaseBridgeElement);
  seal(BaseBridgeElement.prototype);
  /*
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var swappedTemplateMap = new WeakMap();
  var swappedComponentMap = new WeakMap();
  var swappedStyleMap = new WeakMap();
  var activeTemplates = new WeakMap();
  var activeComponents = new WeakMap();
  var activeStyles = new WeakMap();
  function rehydrateHotTemplate(tpl) {
      var list = activeTemplates.get(tpl);
      if (!isUndefined$1(list)) {
          list.forEach(function(vm) {
              if (isFalse(vm.isDirty)) {
                  // forcing the vm to rehydrate in the micro-task:
                  markComponentAsDirty(vm);
                  scheduleRehydration(vm);
              }
          }); // resetting the Set to release the memory of those vm references
          // since they are not longer related to this template, instead
          // they will get re-associated once these instances are rehydrated.
          list.clear();
      }
      return true;
  }
  function rehydrateHotStyle(style) {
      var list = activeStyles.get(style);
      if (!isUndefined$1(list)) {
          list.forEach(function(vm) {
              // if a style definition is swapped, we must reset
              // vm's template content in the next micro-task:
              forceRehydration(vm);
          }); // resetting the Set to release the memory of those vm references
          // since they are not longer related to this style, instead
          // they will get re-associated once these instances are rehydrated.
          list.clear();
      }
      return true;
  }
  function rehydrateHotComponent(Ctor) {
      var list = activeComponents.get(Ctor);
      var canRefreshAllInstances = true;
      if (!isUndefined$1(list)) {
          list.forEach(function(vm) {
              var owner = vm.owner;
              if (!isNull(owner)) {
                  // if a component class definition is swapped, we must reset
                  // owner's template content in the next micro-task:
                  forceRehydration(owner);
              } else {
                  // the hot swapping for components only work for instances of components
                  // created from a template, root elements can't be swapped because we
                  // don't have a way to force the creation of the element with the same state
                  // of the current element.
                  // Instead, we can report the problem to the caller so it can take action,
                  // for example: reload the entire page.
                  canRefreshAllInstances = false;
              }
          }); // resetting the Set to release the memory of those vm references
          // since they are not longer related to this constructor, instead
          // they will get re-associated once these instances are rehydrated.
          list.clear();
      }
      return canRefreshAllInstances;
  }
  function getTemplateOrSwappedTemplate(tpl) {
      if (process.env.NODE_ENV === "production") {
          // this method should never leak to prod
          throw new ReferenceError();
      }
      if (runtimeFlags.ENABLE_HMR) {
          var visited = new Set();
          while(swappedTemplateMap.has(tpl) && !visited.has(tpl)){
              visited.add(tpl);
              tpl = swappedTemplateMap.get(tpl);
          }
      }
      return tpl;
  }
  function getComponentOrSwappedComponent(Ctor) {
      if (process.env.NODE_ENV === "production") {
          // this method should never leak to prod
          throw new ReferenceError();
      }
      if (runtimeFlags.ENABLE_HMR) {
          var visited = new Set();
          while(swappedComponentMap.has(Ctor) && !visited.has(Ctor)){
              visited.add(Ctor);
              Ctor = swappedComponentMap.get(Ctor);
          }
      }
      return Ctor;
  }
  function getStyleOrSwappedStyle(style) {
      if (process.env.NODE_ENV === "production") {
          // this method should never leak to prod
          throw new ReferenceError();
      }
      if (runtimeFlags.ENABLE_HMR) {
          var visited = new Set();
          while(swappedStyleMap.has(style) && !visited.has(style)){
              visited.add(style);
              style = swappedStyleMap.get(style);
          }
      }
      return style;
  }
  function setActiveVM(vm) {
      if (process.env.NODE_ENV === "production") {
          // this method should never leak to prod
          throw new ReferenceError();
      }
      if (runtimeFlags.ENABLE_HMR) {
          // tracking active component
          var Ctor = vm.def.ctor;
          var componentVMs = activeComponents.get(Ctor);
          if (isUndefined$1(componentVMs)) {
              componentVMs = new Set();
              activeComponents.set(Ctor, componentVMs);
          } // this will allow us to keep track of the hot components
          componentVMs.add(vm); // tracking active template
          var tpl = vm.cmpTemplate;
          if (tpl) {
              var templateVMs = activeTemplates.get(tpl);
              if (isUndefined$1(templateVMs)) {
                  templateVMs = new Set();
                  activeTemplates.set(tpl, templateVMs);
              } // this will allow us to keep track of the templates that are
              // being used by a hot component
              templateVMs.add(vm); // tracking active styles associated to template
              var stylesheets = tpl.stylesheets;
              if (!isUndefined$1(stylesheets)) {
                  flattenStylesheets(stylesheets).forEach(function(stylesheet) {
                      // this is necessary because we don't hold the list of styles
                      // in the vm, we only hold the selected (already swapped template)
                      // but the styles attached to the template might not be the actual
                      // active ones, but the swapped versions of those.
                      stylesheet = getStyleOrSwappedStyle(stylesheet);
                      var stylesheetVMs = activeStyles.get(stylesheet);
                      if (isUndefined$1(stylesheetVMs)) {
                          stylesheetVMs = new Set();
                          activeStyles.set(stylesheet, stylesheetVMs);
                      } // this will allow us to keep track of the stylesheet that are
                      // being used by a hot component
                      stylesheetVMs.add(vm);
                  });
              }
          }
      }
  }
  function removeActiveVM(vm) {
      if (process.env.NODE_ENV === "production") {
          // this method should never leak to prod
          throw new ReferenceError();
      }
      if (runtimeFlags.ENABLE_HMR) {
          // tracking inactive component
          var Ctor = vm.def.ctor;
          var list = activeComponents.get(Ctor);
          if (!isUndefined$1(list)) {
              // deleting the vm from the set to avoid leaking memory
              list.delete(vm);
          } // removing inactive template
          var tpl = vm.cmpTemplate;
          if (tpl) {
              list = activeTemplates.get(tpl);
              if (!isUndefined$1(list)) {
                  // deleting the vm from the set to avoid leaking memory
                  list.delete(vm);
              } // removing active styles associated to template
              var styles = tpl.stylesheets;
              if (!isUndefined$1(styles)) {
                  flattenStylesheets(styles).forEach(function(style) {
                      list = activeStyles.get(style);
                      if (!isUndefined$1(list)) {
                          // deleting the vm from the set to avoid leaking memory
                          list.delete(vm);
                      }
                  });
              }
          }
      }
  }
  function swapTemplate(oldTpl, newTpl) {
      if (process.env.NODE_ENV !== "production") {
          if (isTemplateRegistered(oldTpl) && isTemplateRegistered(newTpl)) {
              swappedTemplateMap.set(oldTpl, newTpl);
              return rehydrateHotTemplate(oldTpl);
          } else {
              throw new TypeError("Invalid Template");
          }
      }
      if (!runtimeFlags.ENABLE_HMR) {
          throw new Error("HMR is not enabled");
      }
      return false;
  }
  function swapComponent(oldComponent, newComponent) {
      if (process.env.NODE_ENV !== "production") {
          if (isComponentConstructor(oldComponent) && isComponentConstructor(newComponent)) {
              swappedComponentMap.set(oldComponent, newComponent);
              return rehydrateHotComponent(oldComponent);
          } else {
              throw new TypeError("Invalid Component");
          }
      }
      if (!runtimeFlags.ENABLE_HMR) {
          throw new Error("HMR is not enabled");
      }
      return false;
  }
  function swapStyle(oldStyle, newStyle) {
      if (process.env.NODE_ENV !== "production") {
          // TODO [#1887]: once the support for registering styles is implemented
          // we can add the validation of both styles around this block.
          swappedStyleMap.set(oldStyle, newStyle);
          return rehydrateHotStyle(oldStyle);
      }
      if (!runtimeFlags.ENABLE_HMR) {
          throw new Error("HMR is not enabled");
      }
      return false;
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var CtorToDefMap = new WeakMap();
  function getCtorProto(Ctor) {
      var proto = getPrototypeOf$1(Ctor);
      if (isNull(proto)) {
          throw new ReferenceError("Invalid prototype chain for ".concat(Ctor.name, ", you must extend LightningElement."));
      }
      // covering the cases where the ref is circular in AMD
      if (isCircularModuleDependency(proto)) {
          var p = resolveCircularModuleDependency(proto);
          if (process.env.NODE_ENV !== "production") {
              if (isNull(p)) {
                  throw new ReferenceError("Circular module dependency for ".concat(Ctor.name, ", must resolve to a constructor that extends LightningElement."));
              }
          }
          // escape hatch for Locker and other abstractions to provide their own base class instead
          // of our Base class without having to leak it to user-land. If the circular function returns
          // itself, that's the signal that we have hit the end of the proto chain, which must always
          // be base.
          proto = p === proto ? LightningElement : p;
      }
      return proto;
  }
  function createComponentDef(Ctor) {
      var ctorShadowSupportMode = Ctor.shadowSupportMode, ctorRenderMode = Ctor.renderMode;
      if (process.env.NODE_ENV !== "production") {
          var ctorName = Ctor.name;
          // Removing the following assert until https://bugs.webkit.org/show_bug.cgi?id=190140 is fixed.
          // assert.isTrue(ctorName && isString(ctorName), `${toString(Ctor)} should have a "name" property with string value, but found ${ctorName}.`);
          assert.isTrue(Ctor.constructor, "Missing ".concat(ctorName, ".constructor, ").concat(ctorName, ' should have a "constructor" property.'));
          if (!isUndefined$1(ctorShadowSupportMode)) {
              assert.invariant(ctorShadowSupportMode === "any" /* Any */  || ctorShadowSupportMode === "reset" /* Default */ , "Invalid value for static property shadowSupportMode: '".concat(ctorShadowSupportMode, "'"));
          }
          if (!isUndefined$1(ctorRenderMode)) {
              assert.invariant(ctorRenderMode === "light" || ctorRenderMode === "shadow", "Invalid value for static property renderMode: '".concat(ctorRenderMode, "'. renderMode must be either 'light' or 'shadow'."));
          }
      }
      var decoratorsMeta = getDecoratorsMeta(Ctor);
      var apiFields = decoratorsMeta.apiFields, apiFieldsConfig = decoratorsMeta.apiFieldsConfig, apiMethods = decoratorsMeta.apiMethods, wiredFields = decoratorsMeta.wiredFields, wiredMethods = decoratorsMeta.wiredMethods, observedFields = decoratorsMeta.observedFields;
      var proto = Ctor.prototype;
      var connectedCallback = proto.connectedCallback, disconnectedCallback = proto.disconnectedCallback, renderedCallback = proto.renderedCallback, errorCallback = proto.errorCallback, render = proto.render;
      var superProto = getCtorProto(Ctor);
      var superDef = superProto !== LightningElement ? getComponentInternalDef(superProto) : lightingElementDef;
      var bridge = HTMLBridgeElementFactory(superDef.bridge, keys(apiFields), keys(apiMethods));
      var props = assign(create(null), superDef.props, apiFields);
      var propsConfig = assign(create(null), superDef.propsConfig, apiFieldsConfig);
      var methods = assign(create(null), superDef.methods, apiMethods);
      var wire2 = assign(create(null), superDef.wire, wiredFields, wiredMethods);
      connectedCallback = connectedCallback || superDef.connectedCallback;
      disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;
      renderedCallback = renderedCallback || superDef.renderedCallback;
      errorCallback = errorCallback || superDef.errorCallback;
      render = render || superDef.render;
      var shadowSupportMode = superDef.shadowSupportMode;
      if (!isUndefined$1(ctorShadowSupportMode)) {
          shadowSupportMode = ctorShadowSupportMode;
      }
      var renderMode = superDef.renderMode;
      if (!isUndefined$1(ctorRenderMode)) {
          renderMode = ctorRenderMode === "light" ? 0 /* Light */  : 1 /* Shadow */ ;
      }
      var template = getComponentRegisteredTemplate(Ctor) || superDef.template;
      var name = Ctor.name || superDef.name;
      // installing observed fields into the prototype.
      defineProperties(proto, observedFields);
      var def = {
          ctor: Ctor,
          name: name,
          wire: wire2,
          props: props,
          propsConfig: propsConfig,
          methods: methods,
          bridge: bridge,
          template: template,
          renderMode: renderMode,
          shadowSupportMode: shadowSupportMode,
          connectedCallback: connectedCallback,
          disconnectedCallback: disconnectedCallback,
          renderedCallback: renderedCallback,
          errorCallback: errorCallback,
          render: render
      };
      if (process.env.NODE_ENV !== "production") {
          freeze(Ctor.prototype);
      }
      return def;
  }
  /**
   * EXPERIMENTAL: This function allows for the identification of LWC constructors. This API is
   * subject to change or being removed.
   */ function isComponentConstructor(ctor) {
      if (!isFunction$1(ctor)) {
          return false;
      }
      // Fast path: LightningElement is part of the prototype chain of the constructor.
      if (_instanceof(ctor.prototype, LightningElement)) {
          return true;
      }
      // Slow path: LightningElement is not part of the prototype chain of the constructor, we need
      // climb up the constructor prototype chain to check in case there are circular dependencies
      // to resolve.
      var current = ctor;
      do {
          if (isCircularModuleDependency(current)) {
              var circularResolved = resolveCircularModuleDependency(current);
              // If the circular function returns itself, that's the signal that we have hit the end
              // of the proto chain, which must always be a valid base constructor.
              if (circularResolved === current) {
                  return true;
              }
              current = circularResolved;
          }
          if (current === LightningElement) {
              return true;
          }
      }while (!isNull(current) && (current = getPrototypeOf$1(current)));
      // Finally return false if the LightningElement is not part of the prototype chain.
      return false;
  }
  function getComponentInternalDef(Ctor) {
      if (process.env.NODE_ENV !== "production") {
          Ctor = getComponentOrSwappedComponent(Ctor);
      }
      var def = CtorToDefMap.get(Ctor);
      if (isUndefined$1(def)) {
          if (isCircularModuleDependency(Ctor)) {
              var resolvedCtor = resolveCircularModuleDependency(Ctor);
              def = getComponentInternalDef(resolvedCtor);
              // Cache the unresolved component ctor too. The next time if the same unresolved ctor is used,
              // look up the definition in cache instead of re-resolving and recreating the def.
              CtorToDefMap.set(Ctor, def);
              return def;
          }
          if (!isComponentConstructor(Ctor)) {
              throw new TypeError("".concat(Ctor, ' is not a valid component, or does not extends LightningElement from "lwc". You probably forgot to add the extend clause on the class declaration.'));
          }
          def = createComponentDef(Ctor);
          CtorToDefMap.set(Ctor, def);
      }
      return def;
  }
  function getComponentHtmlPrototype(Ctor) {
      var def = getComponentInternalDef(Ctor);
      return def.bridge;
  }
  var lightingElementDef = {
      ctor: LightningElement,
      name: LightningElement.name,
      props: lightningBasedDescriptors,
      propsConfig: EmptyObject,
      methods: EmptyObject,
      renderMode: 1 /* Shadow */ ,
      shadowSupportMode: "reset" /* Default */ ,
      wire: EmptyObject,
      bridge: BaseBridgeElement,
      template: defaultEmptyTemplate,
      render: LightningElement.prototype.render
  };
  /**
   * EXPERIMENTAL: This function allows for the collection of internal component metadata. This API is
   * subject to change or being removed.
   */ function getComponentDef(Ctor) {
      var def = getComponentInternalDef(Ctor);
      // From the internal def object, we need to extract the info that is useful
      // for some external services, e.g.: Locker Service, usually, all they care
      // is about the shape of the constructor, the internals of it are not relevant
      // because they don't have a way to mess with that.
      var ctor = def.ctor, name = def.name, props = def.props, propsConfig = def.propsConfig, methods = def.methods;
      var publicProps = {};
      for(var key in props){
          // avoid leaking the reference to the public props descriptors
          publicProps[key] = {
              config: propsConfig[key] || 0,
              type: "any" /* any */ ,
              attr: htmlPropertyToAttribute(key)
          };
      }
      var publicMethods = {};
      for(var key1 in methods){
          // avoid leaking the reference to the public method descriptors
          publicMethods[key1] = methods[key1].value;
      }
      return {
          ctor: ctor,
          name: name,
          props: publicProps,
          methods: publicMethods
      };
  }
  /*
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function getUpgradableConstructor(tagName) {
      // Should never get a tag with upper case letter at this point, the compiler should
      // produce only tags with lowercase letters
      // But, for backwards compatibility, we will lower case the tagName
      tagName = tagName.toLowerCase();
      var CE = getCustomElement$1(tagName);
      if (!isUndefined$1(CE)) {
          return CE;
      }
      /**
       * LWC Upgradable Element reference to an element that was created
       * via the scoped registry mechanism, and that is ready to be upgraded.
       */ CE = /*#__PURE__*/ function(HTMLElementExported$11) {
          _inherits(LWCUpgradableElement, HTMLElementExported$11);
          var _super = _createSuper(LWCUpgradableElement);
          function LWCUpgradableElement(upgradeCallback) {
              _classCallCheck(this, LWCUpgradableElement);
              var _this;
              _this = _super.call(this);
              if (isFunction$1(upgradeCallback)) {
                  upgradeCallback(_assertThisInitialized(_this)); // nothing to do with the result for now
              }
              return _this;
          }
          return LWCUpgradableElement;
      }(HTMLElementExported$1);
      defineCustomElement$1(tagName, CE);
      return CE;
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function isVBaseElement(vnode) {
      var type = vnode.type;
      return type === 2 /* Element */  || type === 3 /* CustomElement */ ;
  }
  function isSameVnode(vnode1, vnode2) {
      return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var ColonCharCode = 58;
  function patchAttributes(oldVnode, vnode) {
      var attrs = vnode.data.attrs;
      if (isUndefined$1(attrs)) {
          return;
      }
      var oldAttrs = isNull(oldVnode) ? EmptyObject : oldVnode.data.attrs;
      if (oldAttrs === attrs) {
          return;
      }
      var elm = vnode.elm;
      for(var key in attrs){
          var cur = attrs[key];
          var old = oldAttrs[key];
          if (old !== cur) {
              unlockAttribute(elm, key);
              if (StringCharCodeAt.call(key, 3) === ColonCharCode) {
                  // Assume xml namespace
                  setAttribute$1(elm, key, cur, XML_NAMESPACE);
              } else if (StringCharCodeAt.call(key, 5) === ColonCharCode) {
                  // Assume xlink namespace
                  setAttribute$1(elm, key, cur, XLINK_NAMESPACE);
              } else if (isNull(cur) || isUndefined$1(cur)) {
                  removeAttribute$1(elm, key);
              } else {
                  setAttribute$1(elm, key, cur);
              }
              lockAttribute();
          }
      }
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function isLiveBindingProp(sel, key) {
      // For properties with live bindings, we read values from the DOM element
      // instead of relying on internally tracked values.
      return sel === "input" && (key === "value" || key === "checked");
  }
  function patchProps(oldVnode, vnode) {
      var props = vnode.data.props;
      if (isUndefined$1(props)) {
          return;
      }
      var oldProps = isNull(oldVnode) ? EmptyObject : oldVnode.data.props;
      if (oldProps === props) {
          return;
      }
      var isFirstPatch = isNull(oldVnode);
      var elm = vnode.elm, sel = vnode.sel;
      for(var key in props){
          var cur = props[key];
          // Set the property if it's the first time is is patched or if the previous property is
          // different than the one previously set.
          if (isFirstPatch || cur !== (isLiveBindingProp(sel, key) ? getProperty$1(elm, key) : oldProps[key])) {
              setProperty$1(elm, key, cur);
          }
      }
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var classNameToClassMap = create(null);
  function getMapFromClassName(className) {
      // Intentionally using == to match undefined and null values from computed style attribute
      if (className == null) {
          return EmptyObject;
      }
      // computed class names must be string
      className = isString(className) ? className : className + "";
      var map = classNameToClassMap[className];
      if (map) {
          return map;
      }
      map = create(null);
      var start1 = 0;
      var o;
      var len8 = className.length;
      for(o = 0; o < len8; o++){
          if (StringCharCodeAt.call(className, o) === SPACE_CHAR) {
              if (o > start1) {
                  map[StringSlice.call(className, start1, o)] = true;
              }
              start1 = o + 1;
          }
      }
      if (o > start1) {
          map[StringSlice.call(className, start1, o)] = true;
      }
      classNameToClassMap[className] = map;
      if (process.env.NODE_ENV !== "production") {
          // just to make sure that this object never changes as part of the diffing algo
          freeze(map);
      }
      return map;
  }
  function patchClassAttribute(oldVnode, vnode) {
      var elm = vnode.elm, _data = vnode.data, newClass = _data.className;
      var oldClass = isNull(oldVnode) ? undefined : oldVnode.data.className;
      if (oldClass === newClass) {
          return;
      }
      var classList = getClassList$1(elm);
      var newClassMap = getMapFromClassName(newClass);
      var oldClassMap = getMapFromClassName(oldClass);
      var name;
      for(name in oldClassMap){
          // remove only if it is not in the new class collection and it is not set from within the instance
          if (isUndefined$1(newClassMap[name])) {
              classList.remove(name);
          }
      }
      for(name in newClassMap){
          if (isUndefined$1(oldClassMap[name])) {
              classList.add(name);
          }
      }
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ // The style property is a string when defined via an expression in the template.
  function patchStyleAttribute(oldVnode, vnode) {
      var elm = vnode.elm, _data = vnode.data, newStyle = _data.style;
      var oldStyle = isNull(oldVnode) ? undefined : oldVnode.data.style;
      if (oldStyle === newStyle) {
          return;
      }
      if (!isString(newStyle) || newStyle === "") {
          removeAttribute$1(elm, "style");
      } else {
          setAttribute$1(elm, "style", newStyle);
      }
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function applyEventListeners(vnode) {
      var elm = vnode.elm, on = vnode.data.on;
      if (isUndefined$1(on)) {
          return;
      }
      for(var name in on){
          var handler = on[name];
          addEventListener$1(elm, name, handler);
      }
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ // The HTML class property becomes the vnode.data.classMap object when defined as a string in the template.
  // The compiler takes care of transforming the inline classnames into an object. It's faster to set the
  // different classnames properties individually instead of via a string.
  function applyStaticClassAttribute(vnode) {
      var elm = vnode.elm, classMap = vnode.data.classMap;
      if (isUndefined$1(classMap)) {
          return;
      }
      var classList = getClassList$1(elm);
      for(var name in classMap){
          classList.add(name);
      }
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ // The HTML style property becomes the vnode.data.styleDecls object when defined as a string in the template.
  // The compiler takes care of transforming the inline style into an object. It's faster to set the
  // different style properties individually instead of via a string.
  function applyStaticStyleAttribute(vnode) {
      var elm = vnode.elm, styleDecls = vnode.data.styleDecls;
      if (isUndefined$1(styleDecls)) {
          return;
      }
      for(var _$i8 = 0; _$i8 < styleDecls.length; _$i8++){
          var _i = _slicedToArray(styleDecls[_$i8], 3), prop = _i[0], value = _i[1], important = _i[2];
          setCSSStyleProperty$1(elm, prop, value, important);
      }
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function patchChildren(c1, c2, parent) {
      if (hasDynamicChildren(c2)) {
          updateDynamicChildren(c1, c2, parent);
      } else {
          updateStaticChildren(c1, c2, parent);
      }
  }
  function patch(n1, n2) {
      if (n1 === n2) {
          return;
      }
      if (process.env.NODE_ENV !== "production") {
          if (!isSameVnode(n1, n2)) {
              throw new Error("Expected these VNodes to be the same: " + JSON.stringify({
                  sel: n1.sel,
                  key: n1.key
              }) + ", " + JSON.stringify({
                  sel: n2.sel,
                  key: n2.key
              }));
          }
      }
      switch(n2.type){
          case 0 /* Text */ :
              patchText(n1, n2);
              break;
          case 1 /* Comment */ :
              patchComment(n1, n2);
              break;
          case 2 /* Element */ :
              patchElement(n1, n2);
              break;
          case 3 /* CustomElement */ :
              patchCustomElement(n1, n2);
              break;
      }
  }
  function mount(node, parent, anchor) {
      switch(node.type){
          case 0 /* Text */ :
              mountText(node, parent, anchor);
              break;
          case 1 /* Comment */ :
              mountComment(node, parent, anchor);
              break;
          case 2 /* Element */ :
              mountElement(node, parent, anchor);
              break;
          case 3 /* CustomElement */ :
              mountCustomElement(node, parent, anchor);
              break;
      }
  }
  function patchText(n1, n2) {
      n2.elm = n1.elm;
      if (n2.text !== n1.text) {
          updateTextContent(n2);
      }
  }
  function mountText(node, parent, anchor) {
      var owner = node.owner;
      var textNode = node.elm = createText$1(node.text);
      linkNodeToShadow(textNode, owner);
      insertNode(textNode, parent, anchor);
  }
  function patchComment(n1, n2) {
      n2.elm = n1.elm;
      // FIXME: Comment nodes should be static, we shouldn't need to diff them together. However
      // it is the case today.
      if (n2.text !== n1.text) {
          updateTextContent(n2);
      }
  }
  function mountComment(node, parent, anchor) {
      var owner = node.owner;
      var commentNode = node.elm = createComment$1(node.text);
      linkNodeToShadow(commentNode, owner);
      insertNode(commentNode, parent, anchor);
  }
  function mountElement(vnode, parent, anchor) {
      var sel = vnode.sel, owner = vnode.owner, svg = vnode.data.svg;
      var namespace = isTrue(svg) ? SVG_NAMESPACE : undefined;
      var elm = createElement$2(sel, namespace);
      linkNodeToShadow(elm, owner);
      fallbackElmHook(elm, vnode);
      vnode.elm = elm;
      patchElementPropsAndAttrs$1(null, vnode);
      insertNode(elm, parent, anchor);
      mountVNodes(vnode.children, elm, null);
  }
  function patchElement(n1, n2) {
      var elm = n2.elm = n1.elm;
      patchElementPropsAndAttrs$1(n1, n2);
      patchChildren(n1.children, n2.children, elm);
  }
  function mountCustomElement(vnode, parent, anchor) {
      var sel = vnode.sel, owner = vnode.owner;
      var UpgradableConstructor = getUpgradableConstructor(sel);
      /**
       * Note: if the upgradable constructor does not expect, or throw when we new it
       * with a callback as the first argument, we could implement a more advanced
       * mechanism that only passes that argument if the constructor is known to be
       * an upgradable custom element.
       */ var vm;
      var elm22 = new UpgradableConstructor(function(elm) {
          // the custom element from the registry is expecting an upgrade callback
          vm = createViewModelHook(elm, vnode);
      });
      linkNodeToShadow(elm22, owner);
      vnode.elm = elm22;
      vnode.vm = vm;
      if (vm) {
          allocateChildren(vnode, vm);
      } else if (vnode.ctor !== UpgradableConstructor) {
          throw new TypeError("Incorrect Component Constructor");
      }
      patchElementPropsAndAttrs$1(null, vnode);
      insertNode(elm22, parent, anchor);
      if (vm) {
          if (process.env.NODE_ENV !== "production") {
              assert.isTrue(vm.state === 0 /* created */ , "".concat(vm, " cannot be recycled."));
          }
          runConnectedCallback(vm);
      }
      mountVNodes(vnode.children, elm22, null);
      if (vm) {
          appendVM(vm);
      }
  }
  function patchCustomElement(n1, n2) {
      var elm = n2.elm = n1.elm;
      var vm = n2.vm = n1.vm;
      patchElementPropsAndAttrs$1(n1, n2);
      if (!isUndefined$1(vm)) {
          // in fallback mode, the allocation will always set children to
          // empty and delegate the real allocation to the slot elements
          allocateChildren(n2, vm);
      }
      // in fallback mode, the children will be always empty, so, nothing
      // will happen, but in native, it does allocate the light dom
      patchChildren(n1.children, n2.children, elm);
      if (!isUndefined$1(vm)) {
          // this will probably update the shadowRoot, but only if the vm is in a dirty state
          // this is important to preserve the top to bottom synchronous rendering phase.
          rerenderVM(vm);
      }
  }
  function mountVNodes(vnodes, parent, anchor) {
      var start2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, end1 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : vnodes.length;
      for(; start2 < end1; ++start2){
          var vnode = vnodes[start2];
          if (isVNode(vnode)) {
              mount(vnode, parent, anchor);
          }
      }
  }
  function unmount(vnode, parent) {
      var doRemove = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var type = vnode.type, elm = vnode.elm;
      // When unmounting a VNode subtree not all the elements have to removed from the DOM. The
      // subtree root, is the only element worth unmounting from the subtree.
      if (doRemove) {
          removeNode(elm, parent);
      }
      switch(type){
          case 2 /* Element */ :
              unmountVNodes(vnode.children, elm);
              break;
          case 3 /* CustomElement */ :
              {
                  var vm = vnode.vm;
                  // No need to unmount the children here, `removeVM` will take care of removing the
                  // children.
                  if (!isUndefined$1(vm)) {
                      removeVM(vm);
                  }
              }
      }
  }
  function unmountVNodes(vnodes, parent) {
      var doRemove = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, start3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, end2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : vnodes.length;
      for(; start3 < end2; ++start3){
          var ch = vnodes[start3];
          if (isVNode(ch)) {
              unmount(ch, parent, doRemove);
          }
      }
  }
  function isVNode(vnode) {
      return vnode != null;
  }
  function observeElementChildNodes(elm) {
      elm.$domManual$ = true;
  }
  function setElementShadowToken(elm, token) {
      elm.$shadowToken$ = token;
  }
  // Set the scope token class for *.scoped.css styles
  function setScopeTokenClassIfNecessary(elm, owner) {
      var cmpTemplate = owner.cmpTemplate, context = owner.context;
      var token = cmpTemplate === null || cmpTemplate === void 0 ? void 0 : cmpTemplate.stylesheetToken;
      if (!isUndefined$1(token) && context.hasScopedStyles) {
          getClassList$1(elm).add(token);
      }
  }
  function linkNodeToShadow(elm, owner) {
      var renderRoot = owner.renderRoot, renderMode = owner.renderMode, shadowMode = owner.shadowMode;
      // TODO [#1164]: this should eventually be done by the polyfill directly
      if (isSyntheticShadowDefined$1) {
          if (shadowMode === 1 /* Synthetic */  || renderMode === 0 /* Light */ ) {
              elm[KEY__SHADOW_RESOLVER] = renderRoot[KEY__SHADOW_RESOLVER];
          }
      }
  }
  function updateTextContent(vnode) {
      var elm = vnode.elm, text = vnode.text;
      if (process.env.NODE_ENV !== "production") {
          unlockDomMutation();
      }
      setText$1(elm, text);
      if (process.env.NODE_ENV !== "production") {
          lockDomMutation();
      }
  }
  function insertNode(node, parent, anchor) {
      if (process.env.NODE_ENV !== "production") {
          unlockDomMutation();
      }
      insert$1(node, parent, anchor);
      if (process.env.NODE_ENV !== "production") {
          lockDomMutation();
      }
  }
  function removeNode(node, parent) {
      if (process.env.NODE_ENV !== "production") {
          unlockDomMutation();
      }
      remove$1(node, parent);
      if (process.env.NODE_ENV !== "production") {
          lockDomMutation();
      }
  }
  function patchElementPropsAndAttrs$1(oldVnode, vnode) {
      if (isNull(oldVnode)) {
          applyEventListeners(vnode);
          applyStaticClassAttribute(vnode);
          applyStaticStyleAttribute(vnode);
      }
      // Attrs need to be applied to element before props IE11 will wipe out value on radio inputs if
      // value is set before type=radio.
      patchClassAttribute(oldVnode, vnode);
      patchStyleAttribute(oldVnode, vnode);
      patchAttributes(oldVnode, vnode);
      patchProps(oldVnode, vnode);
  }
  function fallbackElmHook(elm, vnode) {
      var owner = vnode.owner;
      setScopeTokenClassIfNecessary(elm, owner);
      if (owner.shadowMode === 1 /* Synthetic */ ) {
          var context = vnode.data.context;
          var stylesheetToken = owner.context.stylesheetToken;
          if (!isUndefined$1(context) && !isUndefined$1(context.lwc) && context.lwc.dom === "manual" /* Manual */ ) {
              // this element will now accept any manual content inserted into it
              observeElementChildNodes(elm);
          }
          if (!isUndefined$1(stylesheetToken)) {
              // when running in synthetic shadow mode, we need to set the shadowToken value
              // into each element from the template, so they can be styled accordingly.
              setElementShadowToken(elm, stylesheetToken);
          }
      }
      if (process.env.NODE_ENV !== "production") {
          var context1 = vnode.data.context;
          var isPortal = !isUndefined$1(context1) && !isUndefined$1(context1.lwc) && context1.lwc.dom === "manual" /* Manual */ ;
          var isLight = owner.renderMode === 0 /* Light */ ;
          patchElementWithRestrictions(elm, {
              isPortal: isPortal,
              isLight: isLight
          });
      }
  }
  function allocateChildren(vnode, vm) {
      // A component with slots will re-render because:
      // 1- There is a change of the internal state.
      // 2- There is a change on the external api (ex: slots)
      //
      // In case #1, the vnodes in the cmpSlots will be reused since they didn't changed. This routine emptied the
      // slotted children when those VCustomElement were rendered and therefore in subsequent calls to allocate children
      // in a reused VCustomElement, there won't be any slotted children.
      // For those cases, we will use the reference for allocated children stored when rendering the fresh VCustomElement.
      //
      // In case #2, we will always get a fresh VCustomElement.
      var children = vnode.aChildren || vnode.children;
      vm.aChildren = children;
      var renderMode = vm.renderMode, shadowMode = vm.shadowMode;
      if (shadowMode === 1 /* Synthetic */  || renderMode === 0 /* Light */ ) {
          // slow path
          allocateInSlot(vm, children);
          // save the allocated children in case this vnode is reused.
          vnode.aChildren = children;
          // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!
          vnode.children = EmptyArray;
      }
  }
  function createViewModelHook(elm, vnode) {
      var vm = getAssociatedVMIfPresent(elm);
      // There is a possibility that a custom element is registered under tagName, in which case, the
      // initialization is already carry on, and there is nothing else to do here since this hook is
      // called right after invoking `document.createElement`.
      if (!isUndefined$1(vm)) {
          return vm;
      }
      var sel = vnode.sel, mode = vnode.mode, ctor = vnode.ctor, owner = vnode.owner;
      setScopeTokenClassIfNecessary(elm, owner);
      if (owner.shadowMode === 1 /* Synthetic */ ) {
          var stylesheetToken = owner.context.stylesheetToken;
          // when running in synthetic shadow mode, we need to set the shadowToken value
          // into each element from the template, so they can be styled accordingly.
          if (!isUndefined$1(stylesheetToken)) {
              setElementShadowToken(elm, stylesheetToken);
          }
      }
      vm = createVM(elm, ctor, {
          mode: mode,
          owner: owner,
          tagName: sel
      });
      if (process.env.NODE_ENV !== "production") {
          assert.isTrue(isArray$1(vnode.children), "Invalid vnode for a custom element, it must have children defined.");
      }
      return vm;
  }
  function allocateInSlot(vm, children) {
      var _a;
      var oldSlots = vm.cmpSlots;
      var cmpSlots = vm.cmpSlots = create(null);
      for(var _$i10 = 0, len10 = children.length; _$i10 < len10; _$i10 += 1){
          var vnode = children[_$i10];
          if (isNull(vnode)) {
              continue;
          }
          var slotName = "";
          if (isVBaseElement(vnode)) {
              slotName = ((_a = vnode.data.attrs) === null || _a === void 0 ? void 0 : _a.slot) || "";
          }
          var vnodes = cmpSlots[slotName] = cmpSlots[slotName] || [];
          ArrayPush$1.call(vnodes, vnode);
      }
      if (isFalse(vm.isDirty)) {
          // We need to determine if the old allocation is really different from the new one
          // and mark the vm as dirty
          var oldKeys = keys(oldSlots);
          if (oldKeys.length !== keys(cmpSlots).length) {
              markComponentAsDirty(vm);
              return;
          }
          for(var _$i9 = 0, len9 = oldKeys.length; _$i9 < len9; _$i9 += 1){
              var key = oldKeys[_$i9];
              if (isUndefined$1(cmpSlots[key]) || oldSlots[key].length !== cmpSlots[key].length) {
                  markComponentAsDirty(vm);
                  return;
              }
              var oldVNodes = oldSlots[key];
              var vnodes1 = cmpSlots[key];
              for(var j = 0, a = cmpSlots[key].length; j < a; j += 1){
                  if (oldVNodes[j] !== vnodes1[j]) {
                      markComponentAsDirty(vm);
                      return;
                  }
              }
          }
      }
  }
  // Using a WeakMap instead of a WeakSet because this one works in IE11 :(
  var FromIteration = new WeakMap();
  // dynamic children means it was generated by an iteration
  // in a template, and will require a more complex diffing algo.
  function markAsDynamicChildren(children) {
      FromIteration.set(children, 1);
  }
  function hasDynamicChildren(children) {
      return FromIteration.has(children);
  }
  function createKeyToOldIdx(children, beginIdx, endIdx) {
      var map = {};
      // TODO [#1637]: simplify this by assuming that all vnodes has keys
      for(var j = beginIdx; j <= endIdx; ++j){
          var ch = children[j];
          if (isVNode(ch)) {
              var key = ch.key;
              if (key !== undefined) {
                  map[key] = j;
              }
          }
      }
      return map;
  }
  function updateDynamicChildren(oldCh, newCh, parent) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVnode = oldCh[0];
      var oldEndVnode = oldCh[oldEndIdx];
      var newChEnd = newCh.length - 1;
      var newEndIdx = newChEnd;
      var newStartVnode = newCh[0];
      var newEndVnode = newCh[newEndIdx];
      var oldKeyToIdx;
      var idxInOld;
      var elmToMove;
      var before;
      var clonedOldCh = false;
      while(oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx){
          if (!isVNode(oldStartVnode)) {
              oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
          } else if (!isVNode(oldEndVnode)) {
              oldEndVnode = oldCh[--oldEndIdx];
          } else if (!isVNode(newStartVnode)) {
              newStartVnode = newCh[++newStartIdx];
          } else if (!isVNode(newEndVnode)) {
              newEndVnode = newCh[--newEndIdx];
          } else if (isSameVnode(oldStartVnode, newStartVnode)) {
              patch(oldStartVnode, newStartVnode);
              oldStartVnode = oldCh[++oldStartIdx];
              newStartVnode = newCh[++newStartIdx];
          } else if (isSameVnode(oldEndVnode, newEndVnode)) {
              patch(oldEndVnode, newEndVnode);
              oldEndVnode = oldCh[--oldEndIdx];
              newEndVnode = newCh[--newEndIdx];
          } else if (isSameVnode(oldStartVnode, newEndVnode)) {
              // Vnode moved right
              patch(oldStartVnode, newEndVnode);
              insertNode(oldStartVnode.elm, parent, nextSibling$1(oldEndVnode.elm));
              oldStartVnode = oldCh[++oldStartIdx];
              newEndVnode = newCh[--newEndIdx];
          } else if (isSameVnode(oldEndVnode, newStartVnode)) {
              // Vnode moved left
              patch(oldEndVnode, newStartVnode);
              insertNode(newStartVnode.elm, parent, oldStartVnode.elm);
              oldEndVnode = oldCh[--oldEndIdx];
              newStartVnode = newCh[++newStartIdx];
          } else {
              if (oldKeyToIdx === undefined) {
                  oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
              }
              idxInOld = oldKeyToIdx[newStartVnode.key];
              if (isUndefined$1(idxInOld)) {
                  // New element
                  mount(newStartVnode, parent, oldStartVnode.elm);
                  newStartVnode = newCh[++newStartIdx];
              } else {
                  elmToMove = oldCh[idxInOld];
                  if (isVNode(elmToMove)) {
                      if (elmToMove.sel !== newStartVnode.sel) {
                          // New element
                          mount(newStartVnode, parent, oldStartVnode.elm);
                      } else {
                          patch(elmToMove, newStartVnode);
                          // Delete the old child, but copy the array since it is read-only.
                          // The `oldCh` will be GC'ed after `updateDynamicChildren` is complete,
                          // so we only care about the `oldCh` object inside this function.
                          // To avoid cloning over and over again, we check `clonedOldCh`
                          // and only clone once.
                          if (!clonedOldCh) {
                              clonedOldCh = true;
                              oldCh = _toConsumableArray(oldCh);
                          }
                          // We've already cloned at least once, so it's no longer read-only
                          oldCh[idxInOld] = undefined;
                          insertNode(elmToMove.elm, parent, oldStartVnode.elm);
                      }
                  }
                  newStartVnode = newCh[++newStartIdx];
              }
          }
      }
      if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
          if (oldStartIdx > oldEndIdx) {
              // There's some cases in which the sub array of vnodes to be inserted is followed by null(s) and an
              // already processed vnode, in such cases the vnodes to be inserted should be before that processed vnode.
              var _$i11 = newEndIdx;
              var n;
              do {
                  n = newCh[++_$i11];
              }while (!isVNode(n) && _$i11 < newChEnd);
              before = isVNode(n) ? n.elm : null;
              mountVNodes(newCh, parent, before, newStartIdx, newEndIdx + 1);
          } else {
              unmountVNodes(oldCh, parent, true, oldStartIdx, oldEndIdx + 1);
          }
      }
  }
  function updateStaticChildren(c1, c2, parent) {
      var c1Length = c1.length;
      var c2Length = c2.length;
      if (c1Length === 0) {
          // the old list is empty, we can directly insert anything new
          mountVNodes(c2, parent, null);
          return;
      }
      if (c2Length === 0) {
          // the old list is nonempty and the new list is empty so we can directly remove all old nodes
          // this is the case in which the dynamic children of an if-directive should be removed
          unmountVNodes(c1, parent, true);
          return;
      }
      // if the old list is not empty, the new list MUST have the same
      // amount of nodes, that's why we call this static children
      var anchor = null;
      for(var _$i12 = c2Length - 1; _$i12 >= 0; _$i12 -= 1){
          var n1 = c1[_$i12];
          var n2 = c2[_$i12];
          if (n2 !== n1) {
              if (isVNode(n1)) {
                  if (isVNode(n2)) {
                      // both vnodes are equivalent, and we just need to patch them
                      patch(n1, n2);
                      anchor = n2.elm;
                  } else {
                      // removing the old vnode since the new one is null
                      unmount(n1, parent, true);
                  }
              } else if (isVNode(n2)) {
                  mount(n2, parent, anchor);
                  anchor = n2.elm;
              }
          }
      }
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var SymbolIterator = Symbol.iterator;
  function addVNodeToChildLWC(vnode) {
      ArrayPush$1.call(getVMBeingRendered().velements, vnode);
  }
  // [h]tml node
  function h(sel, data) {
      var children = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : EmptyArray;
      var vmBeingRendered6 = getVMBeingRendered();
      if (process.env.NODE_ENV !== "production") {
          assert.isTrue(isString(sel), "h() 1st argument sel must be a string.");
          assert.isTrue(isObject(data), "h() 2nd argument data must be an object.");
          assert.isTrue(isArray$1(children), "h() 3rd argument children must be an array.");
          assert.isTrue("key" in data, " <".concat(sel, '> "key" attribute is invalid or missing for ').concat(vmBeingRendered6, ". Key inside iterator is either undefined or null."));
          // checking reserved internal data properties
          assert.isFalse(data.className && data.classMap, "vnode.data.className and vnode.data.classMap ambiguous declaration.");
          assert.isFalse(data.styleDecls && data.style, "vnode.data.styleDecls and vnode.data.style ambiguous declaration.");
          if (data.style && !isString(data.style)) {
              logError("Invalid 'style' attribute passed to <".concat(sel, "> is ignored. This attribute must be a string value."), vmBeingRendered6);
          }
          forEach.call(children, function(childVnode) {
              if (childVnode != null) {
                  assert.isTrue("type" in childVnode && "sel" in childVnode && "elm" in childVnode && "key" in childVnode, "".concat(childVnode, " is not a vnode."));
              }
          });
      }
      var elm;
      var key = data.key;
      return {
          type: 2 /* Element */ ,
          sel: sel,
          data: data,
          children: children,
          elm: elm,
          key: key,
          owner: vmBeingRendered6
      };
  }
  // [t]ab[i]ndex function
  function ti(value) {
      // if value is greater than 0, we normalize to 0
      // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through
      // If value is less than -1, we don't care
      var shouldNormalize = value > 0 && !(isTrue(value) || isFalse(value));
      if (process.env.NODE_ENV !== "production") {
          var vmBeingRendered7 = getVMBeingRendered();
          if (shouldNormalize) {
              logError("Invalid tabindex value `".concat(toString$1(value), "` in template for ").concat(vmBeingRendered7, ". This attribute must be set to 0 or -1."), vmBeingRendered7);
          }
      }
      return shouldNormalize ? 0 : value;
  }
  // [s]lot element node
  function s(slotName, data, children, slotset) {
      if (process.env.NODE_ENV !== "production") {
          assert.isTrue(isString(slotName), "s() 1st argument slotName must be a string.");
          assert.isTrue(isObject(data), "s() 2nd argument data must be an object.");
          assert.isTrue(isArray$1(children), "h() 3rd argument children must be an array.");
      }
      if (!isUndefined$1(slotset) && !isUndefined$1(slotset[slotName]) && slotset[slotName].length !== 0) {
          children = slotset[slotName];
      }
      var vmBeingRendered8 = getVMBeingRendered();
      var renderMode = vmBeingRendered8.renderMode, shadowMode = vmBeingRendered8.shadowMode;
      if (renderMode === 0 /* Light */ ) {
          sc(children);
          return children;
      }
      if (shadowMode === 1 /* Synthetic */ ) {
          // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
          sc(children);
      }
      return h("slot", data, children);
  }
  // [c]ustom element node
  function c(sel, Ctor, data) {
      var children = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : EmptyArray;
      var vmBeingRendered9 = getVMBeingRendered();
      if (process.env.NODE_ENV !== "production") {
          assert.isTrue(isString(sel), "c() 1st argument sel must be a string.");
          assert.isTrue(isFunction$1(Ctor), "c() 2nd argument Ctor must be a function.");
          assert.isTrue(isObject(data), "c() 3nd argument data must be an object.");
          assert.isTrue(arguments.length === 3 || isArray$1(children), "c() 4nd argument data must be an array.");
          // checking reserved internal data properties
          assert.isFalse(data.className && data.classMap, "vnode.data.className and vnode.data.classMap ambiguous declaration.");
          assert.isFalse(data.styleDecls && data.style, "vnode.data.styleDecls and vnode.data.style ambiguous declaration.");
          if (data.style && !isString(data.style)) {
              logError("Invalid 'style' attribute passed to <".concat(sel, "> is ignored. This attribute must be a string value."), vmBeingRendered9);
          }
          if (arguments.length === 4) {
              forEach.call(children, function(childVnode) {
                  if (childVnode != null) {
                      assert.isTrue("type" in childVnode && "sel" in childVnode && "elm" in childVnode && "key" in childVnode, "".concat(childVnode, " is not a vnode."));
                  }
              });
          }
      }
      var key = data.key;
      var elm, aChildren, vm;
      var vnode = {
          type: 3 /* CustomElement */ ,
          sel: sel,
          data: data,
          children: children,
          elm: elm,
          key: key,
          ctor: Ctor,
          owner: vmBeingRendered9,
          mode: "open",
          aChildren: aChildren,
          vm: vm
      };
      addVNodeToChildLWC(vnode);
      return vnode;
  }
  // [i]terable node
  function i(iterable, factory) {
      var list = [];
      // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
      sc(list);
      var vmBeingRendered10 = getVMBeingRendered();
      if (isUndefined$1(iterable) || iterable === null) {
          if (process.env.NODE_ENV !== "production") {
              logError('Invalid template iteration for value "'.concat(toString$1(iterable), '" in ').concat(vmBeingRendered10, ". It must be an Array or an iterable Object."), vmBeingRendered10);
          }
          return list;
      }
      if (process.env.NODE_ENV !== "production") {
          assert.isFalse(isUndefined$1(iterable[SymbolIterator]), "Invalid template iteration for value `".concat(toString$1(iterable), "` in ").concat(vmBeingRendered10, ". It must be an array-like object and not `null` nor `undefined`."));
      }
      var iterator = iterable[SymbolIterator]();
      if (process.env.NODE_ENV !== "production") {
          assert.isTrue(iterator && isFunction$1(iterator.next), 'Invalid iterator function for "'.concat(toString$1(iterable), '" in ').concat(vmBeingRendered10, "."));
      }
      var next = iterator.next();
      var j = 0;
      var value = next.value, last = next.done;
      var keyMap;
      var iterationError;
      if (process.env.NODE_ENV !== "production") {
          keyMap = create(null);
      }
      while(last === false){
          // implementing a look-back-approach because we need to know if the element is the last
          next = iterator.next();
          last = next.done;
          // template factory logic based on the previous collected value
          var vnode = factory(value, j, j === 0, last === true);
          if (isArray$1(vnode)) {
              ArrayPush$1.apply(list, vnode);
          } else {
              ArrayPush$1.call(list, vnode);
          }
          if (process.env.NODE_ENV !== "production") {
              var vnodes = isArray$1(vnode) ? vnode : [
                  vnode
              ];
              forEach.call(vnodes, function(childVnode) {
                  if (!isNull(childVnode) && isObject(childVnode) && !isUndefined$1(childVnode.sel)) {
                      var key = childVnode.key;
                      if (isString(key) || isNumber(key)) {
                          if (keyMap[key] === 1 && isUndefined$1(iterationError)) {
                              iterationError = 'Duplicated "key" attribute value for "<'.concat(childVnode.sel, '>" in ').concat(vmBeingRendered10, " for item number ").concat(j, '. A key with value "').concat(childVnode.key, '" appears more than once in the iteration. Key values must be unique numbers or strings.');
                          }
                          keyMap[key] = 1;
                      } else if (isUndefined$1(iterationError)) {
                          iterationError = 'Invalid "key" attribute value in "<'.concat(childVnode.sel, '>" in ').concat(vmBeingRendered10, " for item number ").concat(j, '. Set a unique "key" value on all iterated child elements.');
                      }
                  }
              });
          }
          // preparing next value
          j += 1;
          value = next.value;
      }
      if (process.env.NODE_ENV !== "production") {
          if (!isUndefined$1(iterationError)) {
              logError(iterationError, vmBeingRendered10);
          }
      }
      return list;
  }
  /**
   * [f]lattening
   */ function f(items) {
      if (process.env.NODE_ENV !== "production") {
          assert.isTrue(isArray$1(items), "flattening api can only work with arrays.");
      }
      var len11 = items.length;
      var flattened = [];
      // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
      sc(flattened);
      for(var j = 0; j < len11; j += 1){
          var item = items[j];
          if (isArray$1(item)) {
              ArrayPush$1.apply(flattened, item);
          } else {
              ArrayPush$1.call(flattened, item);
          }
      }
      return flattened;
  }
  // [t]ext node
  function t(text) {
      var sel, key, elm;
      return {
          type: 0 /* Text */ ,
          sel: sel,
          text: text,
          elm: elm,
          key: key,
          owner: getVMBeingRendered()
      };
  }
  // [co]mment node
  function co(text) {
      var sel, key, elm;
      return {
          type: 1 /* Comment */ ,
          sel: sel,
          text: text,
          elm: elm,
          key: key,
          owner: getVMBeingRendered()
      };
  }
  // [d]ynamic text
  function d(value) {
      return value == null ? "" : String(value);
  }
  // [b]ind function
  function b(fn) {
      var vmBeingRendered11 = getVMBeingRendered();
      if (isNull(vmBeingRendered11)) {
          throw new Error();
      }
      var vm = vmBeingRendered11;
      return function(event) {
          invokeEventListener(vm, fn, vm.component, event);
      };
  }
  // [k]ey function
  function k(compilerKey, obj) {
      switch(typeof obj === "undefined" ? "undefined" : _typeof(obj)){
          case "number":
          case "string":
              return compilerKey + ":" + obj;
          case "object":
              if (process.env.NODE_ENV !== "production") {
                  assert.fail('Invalid key value "'.concat(obj, '" in ').concat(getVMBeingRendered(), ". Key must be a string or number."));
              }
      }
  }
  // [g]lobal [id] function
  function gid(id1) {
      var vmBeingRendered12 = getVMBeingRendered();
      if (isUndefined$1(id1) || id1 === "") {
          if (process.env.NODE_ENV !== "production") {
              logError('Invalid id value "'.concat(id1, '". The id attribute must contain a non-empty string.'), vmBeingRendered12);
          }
          return id1;
      }
      // We remove attributes when they are assigned a value of null
      if (isNull(id1)) {
          return null;
      }
      var idx2 = vmBeingRendered12.idx, shadowMode = vmBeingRendered12.shadowMode;
      if (shadowMode === 1 /* Synthetic */ ) {
          return StringReplace.call(id1, /\S+/g, function(id) {
              return "".concat(id, "-").concat(idx2);
          });
      }
      return id1;
  }
  // [f]ragment [id] function
  function fid(url) {
      var vmBeingRendered13 = getVMBeingRendered();
      if (isUndefined$1(url) || url === "") {
          if (process.env.NODE_ENV !== "production") {
              if (isUndefined$1(url)) {
                  logError('Undefined url value for "href" or "xlink:href" attribute. Expected a non-empty string.', vmBeingRendered13);
              }
          }
          return url;
      }
      // We remove attributes when they are assigned a value of null
      if (isNull(url)) {
          return null;
      }
      var idx3 = vmBeingRendered13.idx, shadowMode = vmBeingRendered13.shadowMode;
      // Apply transformation only for fragment-only-urls, and only in shadow DOM
      if (shadowMode === 1 /* Synthetic */  && /^#/.test(url)) {
          return "".concat(url, "-").concat(idx3);
      }
      return url;
  }
  /**
   * Map to store an index value assigned to any dynamic component reference ingested
   * by dc() api. This allows us to generate a unique unique per template per dynamic
   * component reference to avoid diffing algo mismatches.
   */ var DynamicImportedComponentMap = new Map();
  var dynamicImportedComponentCounter = 0;
  /**
   * create a dynamic component via `<x-foo lwc:dynamic={Ctor}>`
   */ function dc(sel, Ctor, data) {
      var children = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : EmptyArray;
      if (process.env.NODE_ENV !== "production") {
          assert.isTrue(isString(sel), "dc() 1st argument sel must be a string.");
          assert.isTrue(isObject(data), "dc() 3nd argument data must be an object.");
          assert.isTrue(arguments.length === 3 || isArray$1(children), "dc() 4nd argument data must be an array.");
      }
      // null or undefined values should produce a null value in the VNodes
      if (Ctor == null) {
          return null;
      }
      if (!isComponentConstructor(Ctor)) {
          throw new Error("Invalid LWC Constructor ".concat(toString$1(Ctor), " for custom element <").concat(sel, ">."));
      }
      var idx4 = DynamicImportedComponentMap.get(Ctor);
      if (isUndefined$1(idx4)) {
          idx4 = dynamicImportedComponentCounter++;
          DynamicImportedComponentMap.set(Ctor, idx4);
      }
      // the new vnode key is a mix of idx and compiler key, this is required by the diffing algo
      // to identify different constructors as vnodes with different keys to avoid reusing the
      // element used for previous constructors.
      // Shallow clone is necessary here becuase VElementData may be shared across VNodes due to
      // hoisting optimization.
      var newData = Object.assign(Object.assign({}, data), {
          key: "dc:".concat(idx4, ":").concat(data.key)
      });
      return c(sel, Ctor, newData, children);
  }
  /**
   * slow children collection marking mechanism. this API allows the compiler to signal
   * to the engine that a particular collection of children must be diffed using the slow
   * algo based on keys due to the nature of the list. E.g.:
   *
   *   - slot element's children: the content of the slot has to be dynamic when in synthetic
   *                              shadow mode because the `vnode.children` might be the slotted
   *                              content vs default content, in which case the size and the
   *                              keys are not matching.
   *   - children that contain dynamic components
   *   - children that are produced by iteration
   *
   */ function sc(vnodes) {
      if (process.env.NODE_ENV !== "production") {
          assert.isTrue(isArray$1(vnodes), "sc() api can only work with arrays.");
      }
      // We have to mark the vnodes collection as dynamic so we can later on
      // choose to use the snabbdom virtual dom diffing algo instead of our
      // static dummy algo.
      markAsDynamicChildren(vnodes);
      return vnodes;
  }
  /**
   * EXPERIMENTAL: This function acts like a hook for Lightning Locker Service and other similar
   * libraries to sanitize HTML content. This hook process the content passed via the template to
   * lwc:inner-html directive.
   * It is meant to be overridden with setSanitizeHtmlContentHook, it throws an error by default.
   */ var sanitizeHtmlContentHook = function() {
      // locker-service patches this function during runtime to sanitize HTML content.
      throw new Error("sanitizeHtmlContent hook must be implemented.");
  };
  /**
   * Sets the sanitizeHtmlContentHook.
   */ function setSanitizeHtmlContentHook(newHookImpl) {
      sanitizeHtmlContentHook = newHookImpl;
  }
  // [s]anitize [h]tml [c]ontent
  function shc(content) {
      return sanitizeHtmlContentHook(content);
  }
  var api = freeze({
      s: s,
      h: h,
      c: c,
      i: i,
      f: f,
      t: t,
      d: d,
      b: b,
      k: k,
      co: co,
      dc: dc,
      ti: ti,
      gid: gid,
      fid: fid,
      shc: shc
  });
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function makeHostToken(token) {
      return "".concat(token, "-host");
  }
  function createInlineStyleVNode(content) {
      return api.h("style", {
          key: "style",
          attrs: {
              type: "text/css"
          }
      }, [
          api.t(content)
      ]);
  }
  function updateStylesheetToken(vm, template) {
      var elm = vm.elm, context = vm.context, renderMode = vm.renderMode, shadowMode = vm.shadowMode;
      var newStylesheets = template.stylesheets, newStylesheetToken = template.stylesheetToken;
      var isSyntheticShadow = renderMode === 1 /* Shadow */  && shadowMode === 1 /* Synthetic */ ;
      var hasScopedStyles = context.hasScopedStyles;
      var newToken;
      var newHasTokenInClass;
      var newHasTokenInAttribute;
      // Reset the styling token applied to the host element.
      var oldToken = context.stylesheetToken, oldHasTokenInClass = context.hasTokenInClass, oldHasTokenInAttribute = context.hasTokenInAttribute;
      if (!isUndefined$1(oldToken)) {
          if (oldHasTokenInClass) {
              getClassList$1(elm).remove(makeHostToken(oldToken));
          }
          if (oldHasTokenInAttribute) {
              removeAttribute$1(elm, makeHostToken(oldToken));
          }
      }
      // Apply the new template styling token to the host element, if the new template has any
      // associated stylesheets. In the case of light DOM, also ensure there is at least one scoped stylesheet.
      if (!isUndefined$1(newStylesheets) && newStylesheets.length !== 0) {
          newToken = newStylesheetToken;
      }
      // Set the new styling token on the host element
      if (!isUndefined$1(newToken)) {
          if (hasScopedStyles) {
              getClassList$1(elm).add(makeHostToken(newToken));
              newHasTokenInClass = true;
          }
          if (isSyntheticShadow) {
              setAttribute$1(elm, makeHostToken(newToken), "");
              newHasTokenInAttribute = true;
          }
      }
      // Update the styling tokens present on the context object.
      context.stylesheetToken = newToken;
      context.hasTokenInClass = newHasTokenInClass;
      context.hasTokenInAttribute = newHasTokenInAttribute;
  }
  function evaluateStylesheetsContent(stylesheets, stylesheetToken, vm) {
      var content = [];
      var root;
      for(var _$i13 = 0; _$i13 < stylesheets.length; _$i13++){
          var stylesheet = stylesheets[_$i13];
          if (isArray$1(stylesheet)) {
              ArrayPush$1.apply(content, evaluateStylesheetsContent(stylesheet, stylesheetToken, vm));
          } else {
              if (process.env.NODE_ENV !== "production") {
                  // Check for compiler version mismatch in dev mode only
                  checkVersionMismatch(stylesheet, "stylesheet");
                  // in dev-mode, we support hot swapping of stylesheet, which means that
                  // the component instance might be attempting to use an old version of
                  // the stylesheet, while internally, we have a replacement for it.
                  stylesheet = getStyleOrSwappedStyle(stylesheet);
              }
              var isScopedCss = stylesheet[KEY__SCOPED_CSS];
              // Apply the scope token only if the stylesheet itself is scoped, or if we're rendering synthetic shadow.
              var scopeToken = isScopedCss || vm.shadowMode === 1 /* Synthetic */  && vm.renderMode === 1 /* Shadow */  ? stylesheetToken : undefined;
              // Use the actual `:host` selector if we're rendering global CSS for light DOM, or if we're rendering
              // native shadow DOM. Synthetic shadow DOM never uses `:host`.
              var useActualHostSelector = vm.renderMode === 0 /* Light */  ? !isScopedCss : vm.shadowMode === 0 /* Native */ ;
              // Use the native :dir() pseudoclass only in native shadow DOM. Otherwise, in synthetic shadow,
              // we use an attribute selector on the host to simulate :dir().
              var useNativeDirPseudoclass = void 0;
              if (vm.renderMode === 1 /* Shadow */ ) {
                  useNativeDirPseudoclass = vm.shadowMode === 0 /* Native */ ;
              } else {
                  // Light DOM components should only render `[dir]` if they're inside of a synthetic shadow root.
                  // At the top level (root is null) or inside of a native shadow root, they should use `:dir()`.
                  if (isUndefined$1(root)) {
                      // Only calculate the root once as necessary
                      root = getNearestShadowComponent(vm);
                  }
                  useNativeDirPseudoclass = isNull(root) || root.shadowMode === 0 /* Native */ ;
              }
              ArrayPush$1.call(content, stylesheet(scopeToken, useActualHostSelector, useNativeDirPseudoclass));
          }
      }
      return content;
  }
  function getStylesheetsContent(vm, template) {
      var stylesheets = template.stylesheets, stylesheetToken = template.stylesheetToken;
      var content = [];
      if (!isUndefined$1(stylesheets) && stylesheets.length !== 0) {
          content = evaluateStylesheetsContent(stylesheets, stylesheetToken, vm);
      }
      return content;
  }
  // It might be worth caching this to avoid doing the lookup repeatedly, but
  // perf testing has not shown it to be a huge improvement yet:
  // https://github.com/salesforce/lwc/pull/2460#discussion_r691208892
  function getNearestShadowComponent(vm) {
      var owner = vm;
      while(!isNull(owner)){
          if (owner.renderMode === 1 /* Shadow */ ) {
              return owner;
          }
          owner = owner.owner;
      }
      return owner;
  }
  function getNearestNativeShadowComponent(vm) {
      var owner = getNearestShadowComponent(vm);
      if (!isNull(owner) && owner.shadowMode === 1 /* Synthetic */ ) {
          // Synthetic-within-native is impossible. So if the nearest shadow component is
          // synthetic, we know we won't find a native component if we go any further.
          return null;
      }
      return owner;
  }
  function createStylesheet(vm, stylesheets) {
      var renderMode = vm.renderMode, shadowMode = vm.shadowMode;
      if (renderMode === 1 /* Shadow */  && shadowMode === 1 /* Synthetic */ ) {
          for(var _$i15 = 0; _$i15 < stylesheets.length; _$i15++){
              insertGlobalStylesheet$1(stylesheets[_$i15]);
          }
      } else if (ssr$1 || isHydrating$1()) {
          // Note: We need to ensure that during hydration, the stylesheets method is the same as those in ssr.
          //       This works in the client, because the stylesheets are created, and cached in the VM
          //       the first time the VM renders.
          // native shadow or light DOM, SSR
          var combinedStylesheetContent = ArrayJoin.call(stylesheets, "\n");
          return createInlineStyleVNode(combinedStylesheetContent);
      } else {
          // native shadow or light DOM, DOM renderer
          var root = getNearestNativeShadowComponent(vm);
          var isGlobal = isNull(root);
          for(var _$i14 = 0; _$i14 < stylesheets.length; _$i14++){
              if (isGlobal) {
                  insertGlobalStylesheet$1(stylesheets[_$i14]);
              } else {
                  // local level
                  insertStylesheet$1(stylesheets[_$i14], root.shadowRoot);
              }
          }
      }
      return null;
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var operationIdNameMapping = [
      "constructor",
      "render",
      "patch",
      "connectedCallback",
      "renderedCallback",
      "disconnectedCallback",
      "errorCallback",
      "lwc-hydrate",
      "lwc-rehydrate", 
  ];
  // Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.
  // JSDom (used in Jest) for example doesn't implement the UserTiming APIs.
  var isUserTimingSupported = typeof performance !== "undefined" && typeof performance.mark === "function" && typeof performance.clearMarks === "function" && typeof performance.measure === "function" && typeof performance.clearMeasures === "function";
  var start = !isUserTimingSupported ? noop : function(markName) {
      performance.mark(markName);
  };
  var end = !isUserTimingSupported ? noop : function(measureName, markName) {
      performance.measure(measureName, markName);
      // Clear the created marks and measure to avoid filling the performance entries buffer.
      // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.
      performance.clearMarks(markName);
      performance.clearMeasures(measureName);
  };
  function getOperationName(opId) {
      return operationIdNameMapping[opId];
  }
  function getMeasureName(opId, vm) {
      return "".concat(getComponentTag(vm), " - ").concat(getOperationName(opId));
  }
  function getMarkName(opId, vm) {
      // Adding the VM idx to the mark name creates a unique mark name component instance. This is necessary to produce
      // the right measures for components that are recursive.
      return "".concat(getMeasureName(opId, vm), " - ").concat(vm.idx);
  }
  /** Indicates if operations should be logged via the User Timing API. */ var isMeasureEnabled = process.env.NODE_ENV !== "production";
  /** Indicates if operations should be logged by the profiler. */ var isProfilerEnabled = false;
  /** The currently assigned profiler dispatcher. */ var currentDispatcher = noop;
  var profilerControl = {
      enableProfiler: function enableProfiler() {
          isProfilerEnabled = true;
      },
      disableProfiler: function disableProfiler() {
          isProfilerEnabled = false;
      },
      attachDispatcher: function attachDispatcher(dispatcher) {
          currentDispatcher = dispatcher;
          this.enableProfiler();
      },
      detachDispatcher: function detachDispatcher() {
          var dispatcher = currentDispatcher;
          currentDispatcher = noop;
          this.disableProfiler();
          return dispatcher;
      }
  };
  function logOperationStart(opId, vm) {
      if (isMeasureEnabled) {
          var markName = getMarkName(opId, vm);
          start(markName);
      }
      if (isProfilerEnabled) {
          currentDispatcher(opId, 0 /* Start */ , vm.tagName, vm.idx, vm.renderMode, vm.shadowMode);
      }
  }
  function logOperationEnd(opId, vm) {
      if (isMeasureEnabled) {
          var markName = getMarkName(opId, vm);
          var measureName = getMeasureName(opId, vm);
          end(measureName, markName);
      }
      if (isProfilerEnabled) {
          currentDispatcher(opId, 1 /* Stop */ , vm.tagName, vm.idx, vm.renderMode, vm.shadowMode);
      }
  }
  function logGlobalOperationStart(opId, vm) {
      if (isMeasureEnabled) {
          var opName = getOperationName(opId);
          var markName = isUndefined$1(vm) ? opName : getMarkName(opId, vm);
          start(markName);
      }
      if (isProfilerEnabled) {
          currentDispatcher(opId, 0 /* Start */ , vm === null || vm === void 0 ? void 0 : vm.tagName, vm === null || vm === void 0 ? void 0 : vm.idx, vm === null || vm === void 0 ? void 0 : vm.renderMode, vm === null || vm === void 0 ? void 0 : vm.shadowMode);
      }
  }
  function logGlobalOperationEnd(opId, vm) {
      if (isMeasureEnabled) {
          var opName = getOperationName(opId);
          var markName = isUndefined$1(vm) ? opName : getMarkName(opId, vm);
          end(opName, markName);
      }
      if (isProfilerEnabled) {
          currentDispatcher(opId, 1 /* Stop */ , vm === null || vm === void 0 ? void 0 : vm.tagName, vm === null || vm === void 0 ? void 0 : vm.idx, vm === null || vm === void 0 ? void 0 : vm.renderMode, vm === null || vm === void 0 ? void 0 : vm.shadowMode);
      }
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var isUpdatingTemplate = false;
  var vmBeingRendered = null;
  function getVMBeingRendered() {
      return vmBeingRendered;
  }
  function setVMBeingRendered(vm) {
      vmBeingRendered = vm;
  }
  function validateSlots(vm, html) {
      if (process.env.NODE_ENV === "production") {
          // this method should never leak to prod
          throw new ReferenceError();
      }
      var cmpSlots = vm.cmpSlots;
      var _slots = html.slots, slots = _slots === void 0 ? EmptyArray : _slots;
      for(var slotName in cmpSlots){
          // eslint-disable-next-line lwc-internal/no-production-assert
          assert.isTrue(isArray$1(cmpSlots[slotName]), "Slots can only be set to an array, instead received ".concat(toString$1(cmpSlots[slotName]), ' for slot "').concat(slotName, '" in ').concat(vm, "."));
          if (slotName !== "" && ArrayIndexOf.call(slots, slotName) === -1) {
              // TODO [#1297]: this should never really happen because the compiler should always validate
              // eslint-disable-next-line lwc-internal/no-production-assert
              logError('Ignoring unknown provided slot name "'.concat(slotName, '" in ').concat(vm, ". Check for a typo on the slot attribute."), vm);
          }
      }
  }
  function validateLightDomTemplate(template, vm) {
      if (template === defaultEmptyTemplate) return;
      if (vm.renderMode === 0 /* Light */ ) {
          assert.isTrue(template.renderMode === "light", "Light DOM components can't render shadow DOM templates. Add an 'lwc:render-mode=\"light\"' directive to the root template tag of ".concat(getComponentTag(vm), "."));
      } else {
          assert.isTrue(isUndefined$1(template.renderMode), "Shadow DOM components template can't render light DOM templates. Either remove the 'lwc:render-mode' directive from ".concat(getComponentTag(vm), ' or set it to \'lwc:render-mode="shadow"'));
      }
  }
  function evaluateTemplate(vm, html) {
      if (process.env.NODE_ENV !== "production") {
          assert.isTrue(isFunction$1(html), "evaluateTemplate() second argument must be an imported template instead of ".concat(toString$1(html)));
          // in dev-mode, we support hot swapping of templates, which means that
          // the component instance might be attempting to use an old version of
          // the template, while internally, we have a replacement for it.
          html = getTemplateOrSwappedTemplate(html);
      }
      var isUpdatingTemplateInception = isUpdatingTemplate;
      var vmOfTemplateBeingUpdatedInception = vmBeingRendered;
      var vnodes = [];
      runWithBoundaryProtection(vm, vm.owner, function() {
          // pre
          vmBeingRendered = vm;
          logOperationStart(1 /* Render */ , vm);
      }, function() {
          // job
          var component = vm.component, context = vm.context, cmpSlots = vm.cmpSlots, cmpTemplate = vm.cmpTemplate, tro = vm.tro;
          tro.observe(function() {
              // Reset the cache memoizer for template when needed.
              if (html !== cmpTemplate) {
                  if (process.env.NODE_ENV !== "production") {
                      validateLightDomTemplate(html, vm);
                  }
                  // Perf opt: do not reset the shadow root during the first rendering (there is
                  // nothing to reset).
                  if (!isNull(cmpTemplate)) {
                      // It is important to reset the content to avoid reusing similar elements
                      // generated from a different template, because they could have similar IDs,
                      // and snabbdom just rely on the IDs.
                      resetComponentRoot(vm);
                  }
                  // Check that the template was built by the compiler.
                  if (!isTemplateRegistered(html)) {
                      throw new TypeError("Invalid template returned by the render() method on ".concat(vm, '. It must return an imported template (e.g.: `import html from "./').concat(vm.def.name, '.html"`), instead, it has returned: ').concat(toString$1(html), "."));
                  }
                  vm.cmpTemplate = html;
                  // Create a brand new template cache for the swapped templated.
                  context.tplCache = create(null);
                  // Set the computeHasScopedStyles property in the context, to avoid recomputing it repeatedly.
                  context.hasScopedStyles = computeHasScopedStyles(html);
                  // Update the scoping token on the host element.
                  updateStylesheetToken(vm, html);
                  // Evaluate, create stylesheet and cache the produced VNode for future
                  // re-rendering.
                  var stylesheetsContent = getStylesheetsContent(vm, html);
                  context.styleVNode = stylesheetsContent.length === 0 ? null : createStylesheet(vm, stylesheetsContent);
              }
              if (process.env.NODE_ENV !== "production") {
                  // validating slots in every rendering since the allocated content might change over time
                  validateSlots(vm, html);
                  // add the VM to the list of host VMs that can be re-rendered if html is swapped
                  setActiveVM(vm);
              }
              // right before producing the vnodes, we clear up all internal references
              // to custom elements from the template.
              vm.velements = [];
              // Set the global flag that template is being updated
              isUpdatingTemplate = true;
              vnodes = html.call(undefined, api, component, cmpSlots, context.tplCache);
              var styleVNode = context.styleVNode;
              if (!isNull(styleVNode)) {
                  ArrayUnshift.call(vnodes, styleVNode);
              }
          });
      }, function() {
          // post
          isUpdatingTemplate = isUpdatingTemplateInception;
          vmBeingRendered = vmOfTemplateBeingUpdatedInception;
          logOperationEnd(1 /* Render */ , vm);
      });
      if (process.env.NODE_ENV !== "production") {
          assert.invariant(isArray$1(vnodes), "Compiler should produce html functions that always return an array.");
      }
      return vnodes;
  }
  function computeHasScopedStyles(template) {
      var stylesheets = template.stylesheets;
      if (!isUndefined$1(stylesheets)) {
          for(var _$i16 = 0; _$i16 < stylesheets.length; _$i16++){
              if (isTrue(stylesheets[_$i16][KEY__SCOPED_CSS])) {
                  return true;
              }
          }
      }
      return false;
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var isInvokingRender = false;
  var vmBeingConstructed = null;
  function isBeingConstructed(vm) {
      return vmBeingConstructed === vm;
  }
  function invokeComponentCallback(vm, fn, args) {
      var component = vm.component, callHook3 = vm.callHook, owner = vm.owner;
      runWithBoundaryProtection(vm, owner, noop, function() {
          callHook3(component, fn, args);
      }, noop);
  }
  function invokeComponentConstructor(vm, Ctor) {
      var vmBeingConstructedInception = vmBeingConstructed;
      var error;
      logOperationStart(0 /* Constructor */ , vm);
      vmBeingConstructed = vm;
      /**
       * Constructors don't need to be wrapped with a boundary because for root elements
       * it should throw, while elements from template are already wrapped by a boundary
       * associated to the diffing algo.
       */ try {
          // job
          var result = new Ctor();
          // Check indirectly if the constructor result is an instance of LightningElement. Using
          // the "instanceof" operator would not work here since Locker Service provides its own
          // implementation of LightningElement, so we indirectly check if the base constructor is
          // invoked by accessing the component on the vm.
          if (vmBeingConstructed.component !== result) {
              throw new TypeError("Invalid component constructor, the class should extend LightningElement.");
          }
      } catch (e) {
          error = Object(e);
      } finally{
          logOperationEnd(0 /* Constructor */ , vm);
          vmBeingConstructed = vmBeingConstructedInception;
          if (!isUndefined$1(error)) {
              addErrorComponentStack(vm, error);
              // re-throwing the original error annotated after restoring the context
              throw error; // eslint-disable-line no-unsafe-finally
          }
      }
  }
  function invokeComponentRenderMethod(vm) {
      var render = vm.def.render, callHook4 = vm.callHook, component = vm.component, owner = vm.owner;
      var isRenderBeingInvokedInception = isInvokingRender;
      var vmBeingRenderedInception = getVMBeingRendered();
      var html;
      var renderInvocationSuccessful = false;
      runWithBoundaryProtection(vm, owner, function() {
          // pre
          isInvokingRender = true;
          setVMBeingRendered(vm);
      }, function() {
          // job
          vm.tro.observe(function() {
              html = callHook4(component, render);
              renderInvocationSuccessful = true;
          });
      }, function() {
          // post
          isInvokingRender = isRenderBeingInvokedInception;
          setVMBeingRendered(vmBeingRenderedInception);
      });
      // If render() invocation failed, process errorCallback in boundary and return an empty template
      return renderInvocationSuccessful ? evaluateTemplate(vm, html) : [];
  }
  function invokeEventListener(vm, fn, thisValue, event) {
      var callHook5 = vm.callHook, owner = vm.owner;
      runWithBoundaryProtection(vm, owner, noop, function() {
          // job
          if (process.env.NODE_ENV !== "production") {
              assert.isTrue(isFunction$1(fn), "Invalid event handler for event '".concat(event.type, "' on ").concat(vm, "."));
          }
          callHook5(thisValue, fn, [
              event
          ]);
      }, noop);
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var signedTemplateMap = new Map();
  /**
   * INTERNAL: This function can only be invoked by compiled code. The compiler
   * will prevent this function from being imported by userland code.
   */ function registerComponent(// We typically expect a LightningElementConstructor, but technically you can call this with anything
  Ctor, param) {
      var tmpl = param.tmpl;
      if (isFunction$1(Ctor)) {
          if (process.env.NODE_ENV !== "production") {
              checkVersionMismatch(Ctor, "component");
          }
          signedTemplateMap.set(Ctor, tmpl);
      }
      // chaining this method as a way to wrap existing assignment of component constructor easily,
      // without too much transformation
      return Ctor;
  }
  function getComponentRegisteredTemplate(Ctor) {
      return signedTemplateMap.get(Ctor);
  }
  function getTemplateReactiveObserver(vm) {
      return new ReactiveObserver(function() {
          var isDirty = vm.isDirty;
          if (isFalse(isDirty)) {
              markComponentAsDirty(vm);
              scheduleRehydration(vm);
          }
      });
  }
  function renderComponent(vm) {
      if (process.env.NODE_ENV !== "production") {
          assert.invariant(vm.isDirty, "".concat(vm, " is not dirty."));
      }
      vm.tro.reset();
      var vnodes = invokeComponentRenderMethod(vm);
      vm.isDirty = false;
      vm.isScheduled = false;
      return vnodes;
  }
  function markComponentAsDirty(vm) {
      if (process.env.NODE_ENV !== "production") {
          var vmBeingRendered14 = getVMBeingRendered();
          assert.isFalse(vm.isDirty, "markComponentAsDirty() for ".concat(vm, " should not be called when the component is already dirty."));
          assert.isFalse(isInvokingRender, "markComponentAsDirty() for ".concat(vm, " cannot be called during rendering of ").concat(vmBeingRendered14, "."));
          assert.isFalse(isUpdatingTemplate, "markComponentAsDirty() for ".concat(vm, " cannot be called while updating template of ").concat(vmBeingRendered14, "."));
      }
      vm.isDirty = true;
  }
  var cmpEventListenerMap = new WeakMap();
  function getWrappedComponentsListener(vm, listener) {
      if (!isFunction$1(listener)) {
          throw new TypeError(); // avoiding problems with non-valid listeners
      }
      var wrappedListener = cmpEventListenerMap.get(listener);
      if (isUndefined$1(wrappedListener)) {
          wrappedListener = function wrappedListener(event) {
              invokeEventListener(vm, listener, undefined, event);
          };
          cmpEventListenerMap.set(listener, wrappedListener);
      }
      return wrappedListener;
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var Services = create(null);
  var hooks = [
      "rendered",
      "connected",
      "disconnected"
  ];
  /**
   * EXPERIMENTAL: This function allows for the registration of "services"
   * in LWC by exposing hooks into the component life-cycle. This API is
   * subject to change or being removed.
   */ function register(service) {
      if (process.env.NODE_ENV !== "production") {
          assert.isTrue(isObject(service), "Invalid service declaration, ".concat(service, ": service must be an object"));
      }
      for(var _$i17 = 0; _$i17 < hooks.length; ++_$i17){
          var hookName = hooks[_$i17];
          if (hookName in service) {
              var l = Services[hookName];
              if (isUndefined$1(l)) {
                  Services[hookName] = l = [];
              }
              ArrayPush$1.call(l, service[hookName]);
          }
      }
  }
  function invokeServiceHook(vm, cbs) {
      if (process.env.NODE_ENV !== "production") {
          assert.isTrue(isArray$1(cbs) && cbs.length > 0, "Optimize invokeServiceHook() to be invoked only when needed");
      }
      var component = vm.component, def = vm.def, context = vm.context;
      for(var _$i18 = 0, len12 = cbs.length; _$i18 < len12; ++_$i18){
          cbs[_$i18].call(undefined, component, {}, def, context);
      }
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var idx = 0;
  /** The internal slot used to associate different objects the engine manipulates with the VM */ var ViewModelReflection = new WeakMap();
  function callHook(cmp, fn) {
      var args = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      return fn.apply(cmp, args);
  }
  function setHook(cmp, prop, newValue) {
      cmp[prop] = newValue;
  }
  function getHook(cmp, prop) {
      return cmp[prop];
  }
  function rerenderVM(vm) {
      rehydrate(vm);
  }
  function connectRootElement(elm) {
      var vm = getAssociatedVM(elm);
      logGlobalOperationStart(7, vm); // Usually means moving the element from one place to another, which is observable via
      // life-cycle hooks.
      if (vm.state === 1) {
          disconnectRootElement(elm);
      }
      runConnectedCallback(vm);
      rehydrate(vm);
      logGlobalOperationEnd(7, vm);
  }
  function disconnectRootElement(elm) {
      var vm = getAssociatedVM(elm);
      resetComponentStateWhenRemoved(vm);
  }
  function appendVM(vm) {
      rehydrate(vm);
  } // just in case the component comes back, with this we guarantee re-rendering it
  // while preventing any attempt to rehydration until after reinsertion.
  function resetComponentStateWhenRemoved(vm) {
      var state = vm.state;
      if (state !== 2) {
          var oar = vm.oar, tro = vm.tro; // Making sure that any observing record will not trigger the rehydrated on this vm
          tro.reset(); // Making sure that any observing accessor record will not trigger the setter to be reinvoked
          for(var key in oar){
              oar[key].reset();
          }
          runDisconnectedCallback(vm); // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)
          runChildNodesDisconnectedCallback(vm);
          runLightChildNodesDisconnectedCallback(vm);
      }
      if (process.env.NODE_ENV !== "production") {
          removeActiveVM(vm);
      }
  } // this method is triggered by the diffing algo only when a vnode from the
  // old vnode.children is removed from the DOM.
  function removeVM(vm) {
      if (process.env.NODE_ENV !== "production") {
          assert.isTrue(vm.state === 1 || vm.state === 2, "".concat(vm, " must have been connected."));
      }
      resetComponentStateWhenRemoved(vm);
  }
  function createVM(elm, ctor, options) {
      var _a;
      var mode = options.mode, owner = options.owner, tagName = options.tagName;
      var def = getComponentInternalDef(ctor);
      var vm = {
          elm: elm,
          def: def,
          idx: idx++,
          state: 0,
          isScheduled: false,
          isDirty: true,
          tagName: tagName,
          mode: mode,
          owner: owner,
          children: EmptyArray,
          aChildren: EmptyArray,
          velements: EmptyArray,
          cmpProps: create(null),
          cmpFields: create(null),
          cmpSlots: create(null),
          oar: create(null),
          cmpTemplate: null,
          renderMode: def.renderMode,
          shadowMode: computeShadowMode(def, owner),
          nearestShadowMode: (owner === null || owner === void 0 ? void 0 : owner.shadowRoot) ? owner.shadowMode : (_a = owner === null || owner === void 0 ? void 0 : owner.nearestShadowMode) !== null && _a !== void 0 ? _a : null,
          context: {
              stylesheetToken: undefined,
              hasTokenInClass: undefined,
              hasTokenInAttribute: undefined,
              hasScopedStyles: undefined,
              styleVNode: null,
              tplCache: EmptyObject,
              wiredConnecting: EmptyArray,
              wiredDisconnecting: EmptyArray
          },
          // Properties set right after VM creation.
          tro: null,
          // Properties set by the LightningElement constructor.
          component: null,
          shadowRoot: null,
          renderRoot: null,
          callHook: callHook,
          setHook: setHook,
          getHook: getHook
      };
      vm.tro = getTemplateReactiveObserver(vm);
      if (process.env.NODE_ENV !== "production") {
          vm.toString = function() {
              return "[object:vm ".concat(def.name, " (").concat(vm.idx, ")]");
          };
          if (runtimeFlags.ENABLE_FORCE_NATIVE_SHADOW_MODE_FOR_TEST) {
              vm.shadowMode = 0 /* Native */ ;
          }
      } // Create component instance associated to the vm and the element.
      invokeComponentConstructor(vm, def.ctor); // Initializing the wire decorator per instance only when really needed
      if (hasWireAdapters(vm)) {
          installWireAdapters(vm);
      }
      return vm;
  }
  function computeShadowMode(def, owner) {
      var _a;
      var shadowMode;
      if (isSyntheticShadowDefined$1) {
          if (def.renderMode === 0) {
              // ShadowMode.Native implies "not synthetic shadow" which is consistent with how
              // everything defaults to native when the synthetic shadow polyfill is unavailable.
              shadowMode = 0 /* Native */ ;
          } else if (isNativeShadowDefined$1) {
              // Not combined with above condition because @lwc/features only supports identifiers in
              // the if-condition.
              if (runtimeFlags.ENABLE_MIXED_SHADOW_MODE) {
                  if (def.shadowSupportMode === "any") {
                      shadowMode = 0 /* Native */ ;
                  } else {
                      // Transitive support for native Shadow DOM. A component in native mode
                      // transitively opts all of its descendants into native.
                      // Synthetic if neither this component nor any of its ancestors are configured
                      // to be native.
                      shadowMode = (_a = owner === null || owner === void 0 ? void 0 : owner.nearestShadowMode) !== null && _a !== void 0 ? _a : 1 /* Synthetic */ ;
                  }
              } else {
                  shadowMode = 1 /* Synthetic */ ;
              }
          } else {
              // Synthetic if there is no native Shadow DOM support.
              shadowMode = 1 /* Synthetic */ ;
          }
      } else {
          // Native if the synthetic shadow polyfill is unavailable.
          shadowMode = 0 /* Native */ ;
      }
      return shadowMode;
  }
  function assertIsVM(obj) {
      if (isNull(obj) || !isObject(obj) || !("renderRoot" in obj)) {
          throw new TypeError("".concat(obj, " is not a VM."));
      }
  }
  function associateVM(obj, vm) {
      ViewModelReflection.set(obj, vm);
  }
  function getAssociatedVM(obj) {
      var vm = ViewModelReflection.get(obj);
      if (process.env.NODE_ENV !== "production") {
          assertIsVM(vm);
      }
      return vm;
  }
  function getAssociatedVMIfPresent(obj) {
      var maybeVm = ViewModelReflection.get(obj);
      if (process.env.NODE_ENV !== "production") {
          if (!isUndefined$1(maybeVm)) {
              assertIsVM(maybeVm);
          }
      }
      return maybeVm;
  }
  function rehydrate(vm) {
      if (isTrue(vm.isDirty)) {
          var children = renderComponent(vm);
          patchShadowRoot(vm, children);
      }
  }
  function patchShadowRoot(vm, newCh) {
      var renderRoot = vm.renderRoot, oldCh = vm.children; // caching the new children collection
      vm.children = newCh;
      if (newCh.length > 0 || oldCh.length > 0) {
          // patch function mutates vnodes by adding the element reference,
          // however, if patching fails it contains partial changes.
          if (oldCh !== newCh) {
              runWithBoundaryProtection(vm, vm, function() {
                  // pre
                  logOperationStart(2, vm);
              }, function() {
                  // job
                  patchChildren(oldCh, newCh, renderRoot);
              }, function() {
                  // post
                  logOperationEnd(2, vm);
              });
          }
      }
      if (vm.state === 1) {
          // If the element is connected, that means connectedCallback was already issued, and
          // any successive rendering should finish with the call to renderedCallback, otherwise
          // the connectedCallback will take care of calling it in the right order at the end of
          // the current rehydration process.
          runRenderedCallback(vm);
      }
  }
  function runRenderedCallback(vm) {
      var renderedCallback = vm.def.renderedCallback;
      if (isTrue(ssr$1)) {
          return;
      }
      var rendered = Services.rendered;
      if (rendered) {
          invokeServiceHook(vm, rendered);
      }
      if (!isUndefined$1(renderedCallback)) {
          logOperationStart(4, vm);
          invokeComponentCallback(vm, renderedCallback);
          logOperationEnd(4, vm);
      }
  }
  var rehydrateQueue = [];
  function flushRehydrationQueue() {
      logGlobalOperationStart(8);
      if (process.env.NODE_ENV !== "production") {
          assert.invariant(rehydrateQueue.length, "If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ".concat(rehydrateQueue, "."));
      }
      var vms = rehydrateQueue.sort(function(a, b1) {
          return a.idx - b1.idx;
      });
      rehydrateQueue = []; // reset to a new queue
      for(var _$i19 = 0, len13 = vms.length; _$i19 < len13; _$i19 += 1){
          var vm = vms[_$i19];
          try {
              rehydrate(vm);
          } catch (error) {
              if (_$i19 + 1 < len13) {
                  // pieces of the queue are still pending to be rehydrated, those should have priority
                  if (rehydrateQueue.length === 0) {
                      addCallbackToNextTick(flushRehydrationQueue);
                  }
                  ArrayUnshift.apply(rehydrateQueue, ArraySlice.call(vms, _$i19 + 1));
              } // we need to end the measure before throwing.
              logGlobalOperationEnd(8); // re-throwing the original error will break the current tick, but since the next tick is
              // already scheduled, it should continue patching the rest.
              throw error; // eslint-disable-line no-unsafe-finally
          }
      }
      logGlobalOperationEnd(8);
  }
  function runConnectedCallback(vm) {
      var state = vm.state;
      if (state === 1) {
          return; // nothing to do since it was already connected
      }
      vm.state = 1 /* connected */ ; // reporting connection
      var connected = Services.connected;
      if (connected) {
          invokeServiceHook(vm, connected);
      }
      if (hasWireAdapters(vm)) {
          connectWireAdapters(vm);
      }
      var connectedCallback = vm.def.connectedCallback;
      if (!isUndefined$1(connectedCallback)) {
          logOperationStart(3, vm);
          invokeComponentCallback(vm, connectedCallback);
          logOperationEnd(3, vm);
      }
  }
  function hasWireAdapters(vm) {
      return getOwnPropertyNames$1(vm.def.wire).length > 0;
  }
  function runDisconnectedCallback(vm) {
      if (process.env.NODE_ENV !== "production") {
          assert.isTrue(vm.state !== 2, "".concat(vm, " must be inserted."));
      }
      if (isFalse(vm.isDirty)) {
          // this guarantees that if the component is reused/reinserted,
          // it will be re-rendered because we are disconnecting the reactivity
          // linking, so mutations are not automatically reflected on the state
          // of disconnected components.
          vm.isDirty = true;
      }
      vm.state = 2 /* disconnected */ ; // reporting disconnection
      var disconnected = Services.disconnected;
      if (disconnected) {
          invokeServiceHook(vm, disconnected);
      }
      if (hasWireAdapters(vm)) {
          disconnectWireAdapters(vm);
      }
      var disconnectedCallback = vm.def.disconnectedCallback;
      if (!isUndefined$1(disconnectedCallback)) {
          logOperationStart(5, vm);
          invokeComponentCallback(vm, disconnectedCallback);
          logOperationEnd(5, vm);
      }
  }
  function runChildNodesDisconnectedCallback(vm) {
      var vCustomElementCollection = vm.velements; // Reporting disconnection for every child in inverse order since they are
      // inserted in reserved order.
      for(var _$i20 = vCustomElementCollection.length - 1; _$i20 >= 0; _$i20 -= 1){
          var elm = vCustomElementCollection[_$i20].elm; // There are two cases where the element could be undefined:
          // * when there is an error during the construction phase, and an error
          //   boundary picks it, there is a possibility that the VCustomElement
          //   is not properly initialized, and therefore is should be ignored.
          // * when slotted custom element is not used by the element where it is
          //   slotted into it, as  a result, the custom element was never
          //   initialized.
          if (!isUndefined$1(elm)) {
              var childVM = getAssociatedVMIfPresent(elm); // The VM associated with the element might be associated undefined
              // in the case where the VM failed in the middle of its creation,
              // eg: constructor throwing before invoking super().
              if (!isUndefined$1(childVM)) {
                  resetComponentStateWhenRemoved(childVM);
              }
          }
      }
  }
  function runLightChildNodesDisconnectedCallback(vm) {
      var adoptedChildren = vm.aChildren;
      recursivelyDisconnectChildren(adoptedChildren);
  }
  /**
   * The recursion doesn't need to be a complete traversal of the vnode graph,
   * instead it can be partial, when a custom element vnode is found, we don't
   * need to continue into its children because by attempting to disconnect the
   * custom element itself will trigger the removal of anything slotted or anything
   * defined on its shadow.
   */ function recursivelyDisconnectChildren(vnodes) {
      for(var _$i21 = 0, len14 = vnodes.length; _$i21 < len14; _$i21 += 1){
          var vnode = vnodes[_$i21];
          if (!isNull(vnode) && !isUndefined$1(vnode.elm)) {
              switch(vnode.type){
                  case 2:
                      recursivelyDisconnectChildren(vnode.children);
                      break;
                  case 3:
                      {
                          var vm = getAssociatedVM(vnode.elm);
                          resetComponentStateWhenRemoved(vm);
                          break;
                      }
              }
          }
      }
  } // This is a super optimized mechanism to remove the content of the root node (shadow root
  // for shadow DOM components and the root element itself for light DOM) without having to go
  // into snabbdom. Especially useful when the reset is a consequence of an error, in which case the
  // children VNodes might not be representing the current state of the DOM.
  function resetComponentRoot(vm) {
      var children = vm.children, renderRoot = vm.renderRoot;
      for(var _$i22 = 0, len15 = children.length; _$i22 < len15; _$i22++){
          var child = children[_$i22];
          if (!isNull(child) && !isUndefined$1(child.elm)) {
              remove$1(child.elm, renderRoot);
          }
      }
      vm.children = EmptyArray;
      runChildNodesDisconnectedCallback(vm);
      vm.velements = EmptyArray;
  }
  function scheduleRehydration(vm) {
      if (isTrue(ssr$1) || isTrue(vm.isScheduled)) {
          return;
      }
      vm.isScheduled = true;
      if (rehydrateQueue.length === 0) {
          addCallbackToNextTick(flushRehydrationQueue);
      }
      ArrayPush$1.call(rehydrateQueue, vm);
  }
  function getErrorBoundaryVM(vm) {
      var currentVm = vm;
      while(!isNull(currentVm)){
          if (!isUndefined$1(currentVm.def.errorCallback)) {
              return currentVm;
          }
          currentVm = currentVm.owner;
      }
  }
  function runWithBoundaryProtection(vm, owner, pre, job, post) {
      var error;
      pre();
      try {
          job();
      } catch (e) {
          error = Object(e);
      } finally{
          post();
          if (!isUndefined$1(error)) {
              addErrorComponentStack(vm, error);
              var errorBoundaryVm = isNull(owner) ? undefined : getErrorBoundaryVM(owner);
              if (isUndefined$1(errorBoundaryVm)) {
                  throw error; // eslint-disable-line no-unsafe-finally
              }
              resetComponentRoot(vm); // remove offenders
              logOperationStart(6, vm); // error boundaries must have an ErrorCallback
              var errorCallback = errorBoundaryVm.def.errorCallback;
              invokeComponentCallback(errorBoundaryVm, errorCallback, [
                  error,
                  error.wcStack
              ]);
              logOperationEnd(6, vm);
          }
      }
  }
  function forceRehydration(vm) {
      // if we must reset the shadowRoot content and render the template
      // from scratch on an active instance, the way to force the reset
      // is by replacing the value of old template, which is used during
      // to determine if the template has changed or not during the rendering
      // process. If the template returned by render() is different from the
      // previous stored template, the styles will be reset, along with the
      // content of the shadowRoot, this way we can guarantee that all children
      // elements will be throw away, and new instances will be created.
      vm.cmpTemplate = function() {
          return [];
      };
      if (isFalse(vm.isDirty)) {
          // forcing the vm to rehydrate in the next tick
          markComponentAsDirty(vm);
          scheduleRehydration(vm);
      }
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var DeprecatedWiredElementHost = "$$DeprecatedWiredElementHostKey$$";
  var DeprecatedWiredParamsMeta = "$$DeprecatedWiredParamsMetaKey$$";
  var WireMetaMap = new Map();
  var WireContextRegistrationEvent = /*#__PURE__*/ function(CustomEvent) {
      _inherits(WireContextRegistrationEvent, CustomEvent);
      var _super = _createSuper(WireContextRegistrationEvent);
      function WireContextRegistrationEvent(adapterToken, param) {
          var setNewContext = param.setNewContext, setDisconnectedCallback = param.setDisconnectedCallback;
          _classCallCheck(this, WireContextRegistrationEvent);
          var _this;
          _this = _super.call(this, adapterToken, {
              bubbles: true,
              composed: true
          });
          defineProperties(_assertThisInitialized(_this), {
              setNewContext: {
                  value: setNewContext
              },
              setDisconnectedCallback: {
                  value: setDisconnectedCallback
              }
          });
          return _this;
      }
      return WireContextRegistrationEvent;
  }(_wrapNativeSuper(CustomEvent));
  function createFieldDataCallback(vm, name) {
      var cmpFields = vm.cmpFields;
      return function(value) {
          if (value !== vm.cmpFields[name]) {
              // storing the value in the underlying storage
              cmpFields[name] = value;
              componentValueMutated(vm, name);
          }
      };
  }
  function createMethodDataCallback(vm, method) {
      return function(value) {
          // dispatching new value into the wired method
          runWithBoundaryProtection(vm, vm.owner, noop, function() {
              // job
              method.call(vm.component, value);
          }, noop);
      };
  }
  function createConfigWatcher(component, configCallback, callbackWhenConfigIsReady) {
      var hasPendingConfig = false; // creating the reactive observer for reactive params when needed
      var ro = new ReactiveObserver(function() {
          if (hasPendingConfig === false) {
              hasPendingConfig = true; // collect new config in the micro-task
              Promise.resolve().then(function() {
                  hasPendingConfig = false; // resetting current reactive params
                  ro.reset(); // dispatching a new config due to a change in the configuration
                  computeConfigAndUpdate();
              });
          }
      });
      var computeConfigAndUpdate = function() {
          var config;
          ro.observe(function() {
              return config = configCallback(component);
          }); // eslint-disable-next-line lwc-internal/no-invalid-todo
          // TODO: dev-mode validation of config based on the adapter.configSchema
          // @ts-ignore it is assigned in the observe() callback
          callbackWhenConfigIsReady(config);
      };
      return {
          computeConfigAndUpdate: computeConfigAndUpdate,
          ro: ro
      };
  }
  function createContextWatcher(vm, wireDef, callbackWhenContextIsReady) {
      var adapter = wireDef.adapter;
      var adapterContextToken = getAdapterToken(adapter);
      if (isUndefined$1(adapterContextToken)) {
          return; // no provider found, nothing to be done
      }
      var elm = vm.elm, _context = vm.context, wiredConnecting = _context.wiredConnecting, wiredDisconnecting = _context.wiredDisconnecting; // waiting for the component to be connected to formally request the context via the token
      ArrayPush$1.call(wiredConnecting, function() {
          // This event is responsible for connecting the host element with another
          // element in the composed path that is providing contextual data. The provider
          // must be listening for a special dom event with the name corresponding to the value of
          // `adapterContextToken`, which will remain secret and internal to this file only to
          // guarantee that the linkage can be forged.
          var contextRegistrationEvent = new WireContextRegistrationEvent(adapterContextToken, {
              setNewContext: function setNewContext(newContext) {
                  // eslint-disable-next-line lwc-internal/no-invalid-todo
                  // TODO: dev-mode validation of config based on the adapter.contextSchema
                  callbackWhenContextIsReady(newContext);
              },
              setDisconnectedCallback: function setDisconnectedCallback(disconnectCallback) {
                  // adds this callback into the disconnect bucket so it gets disconnected from parent
                  // the the element hosting the wire is disconnected
                  ArrayPush$1.call(wiredDisconnecting, disconnectCallback);
              }
          });
          dispatchEvent$1(elm, contextRegistrationEvent);
      });
  }
  function createConnector(vm, name, wireDef) {
      var method = wireDef.method, adapter = wireDef.adapter, configCallback = wireDef.configCallback, dynamic = wireDef.dynamic;
      var dataCallback = isUndefined$1(method) ? createFieldDataCallback(vm, name) : createMethodDataCallback(vm, method);
      var context;
      var connector; // Workaround to pass the component element associated to this wire adapter instance.
      defineProperty(dataCallback, DeprecatedWiredElementHost, {
          value: vm.elm
      });
      defineProperty(dataCallback, DeprecatedWiredParamsMeta, {
          value: dynamic
      });
      runWithBoundaryProtection(vm, vm, noop, function() {
          // job
          connector = new adapter(dataCallback);
      }, noop);
      var updateConnectorConfig = function(config) {
          // every time the config is recomputed due to tracking,
          // this callback will be invoked with the new computed config
          runWithBoundaryProtection(vm, vm, noop, function() {
              // job
              connector.update(config, context);
          }, noop);
      }; // Computes the current wire config and calls the update method on the wire adapter.
      // If it has params, we will need to observe changes in the next tick.
      var ref13 = createConfigWatcher(vm.component, configCallback, updateConnectorConfig), computeConfigAndUpdate = ref13.computeConfigAndUpdate, ro = ref13.ro; // if the adapter needs contextualization, we need to watch for new context and push it alongside the config
      if (!isUndefined$1(adapter.contextSchema)) {
          createContextWatcher(vm, wireDef, function(newContext) {
              // every time the context is pushed into this component,
              // this callback will be invoked with the new computed context
              if (context !== newContext) {
                  context = newContext; // Note: when new context arrives, the config will be recomputed and pushed along side the new
                  // context, this is to preserve the identity characteristics, config should not have identity
                  // (ever), while context can have identity
                  if (vm.state === 1) {
                      computeConfigAndUpdate();
                  }
              }
          });
      }
      return {
          // @ts-ignore the boundary protection executes sync, connector is always defined
          connector: connector,
          computeConfigAndUpdate: computeConfigAndUpdate,
          resetConfigWatcher: function() {
              return ro.reset();
          }
      };
  }
  var AdapterToTokenMap = new Map();
  function getAdapterToken(adapter) {
      return AdapterToTokenMap.get(adapter);
  }
  function setAdapterToken(adapter, token) {
      AdapterToTokenMap.set(adapter, token);
  }
  function storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic) {
      // support for callable adapters
      if (adapter.adapter) {
          adapter = adapter.adapter;
      }
      var method = descriptor.value;
      var def = {
          adapter: adapter,
          method: method,
          configCallback: configCallback,
          dynamic: dynamic
      };
      WireMetaMap.set(descriptor, def);
  }
  function storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic) {
      // support for callable adapters
      if (adapter.adapter) {
          adapter = adapter.adapter;
      }
      var def = {
          adapter: adapter,
          configCallback: configCallback,
          dynamic: dynamic
      };
      WireMetaMap.set(descriptor, def);
  }
  function installWireAdapters(vm) {
      var _loop = function(fieldNameOrMethod) {
          var descriptor = wire3[fieldNameOrMethod];
          var wireDef = WireMetaMap.get(descriptor);
          if (process.env.NODE_ENV !== "production") {
              assert.invariant(wireDef, "Internal Error: invalid wire definition found.");
          }
          if (!isUndefined$1(wireDef)) {
              var ref14 = createConnector(vm, fieldNameOrMethod, wireDef), connector = ref14.connector, computeConfigAndUpdate = ref14.computeConfigAndUpdate, resetConfigWatcher = ref14.resetConfigWatcher;
              var hasDynamicParams = wireDef.dynamic.length > 0;
              ArrayPush$1.call(wiredConnecting, function() {
                  connector.connect();
                  if (!runtimeFlags.ENABLE_WIRE_SYNC_EMIT) {
                      if (hasDynamicParams) {
                          Promise.resolve().then(computeConfigAndUpdate);
                          return;
                      }
                  }
                  computeConfigAndUpdate();
              });
              ArrayPush$1.call(wiredDisconnecting, function() {
                  connector.disconnect();
                  resetConfigWatcher();
              });
          }
      };
      var context = vm.context, wire3 = vm.def.wire;
      var wiredConnecting = context.wiredConnecting = [];
      var wiredDisconnecting = context.wiredDisconnecting = [];
      for(var fieldNameOrMethod in wire3)_loop(fieldNameOrMethod);
  }
  function connectWireAdapters(vm) {
      var wiredConnecting = vm.context.wiredConnecting;
      for(var _$i23 = 0, len16 = wiredConnecting.length; _$i23 < len16; _$i23 += 1){
          wiredConnecting[_$i23]();
      }
  }
  function disconnectWireAdapters(vm) {
      var wiredDisconnecting = vm.context.wiredDisconnecting;
      runWithBoundaryProtection(vm, vm, noop, function() {
          // job
          for(var _$i24 = 0, len17 = wiredDisconnecting.length; _$i24 < len17; _$i24 += 1){
              wiredDisconnecting[_$i24]();
          }
      }, noop);
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ // this is lwc internal implementation
  function createContextProvider(adapter) {
      var adapterContextToken = getAdapterToken(adapter);
      if (!isUndefined$1(adapterContextToken)) {
          throw new Error("Adapter already has a context provider.");
      }
      adapterContextToken = guid();
      setAdapterToken(adapter, adapterContextToken);
      var providers = new WeakSet();
      return function(elm, options) {
          if (providers.has(elm)) {
              throw new Error("Adapter was already installed on ".concat(elm, "."));
          }
          providers.add(elm);
          var consumerConnectedCallback = options.consumerConnectedCallback, consumerDisconnectedCallback = options.consumerDisconnectedCallback;
          elm.addEventListener(adapterContextToken, function(evt) {
              var setNewContext = evt.setNewContext, setDisconnectedCallback = evt.setDisconnectedCallback;
              var consumer = {
                  provide: function provide(newContext) {
                      setNewContext(newContext);
                  }
              };
              var disconnectCallback = function() {
                  if (!isUndefined$1(consumerDisconnectedCallback)) {
                      consumerDisconnectedCallback(consumer);
                  }
              };
              setDisconnectedCallback(disconnectCallback);
              consumerConnectedCallback(consumer);
              evt.stopImmediatePropagation();
          });
      };
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ /**
   * EXPERIMENTAL: This function allows you to create a reactive readonly
   * membrane around any object value. This API is subject to change or
   * being removed.
   */ function readonly(obj) {
      if (process.env.NODE_ENV !== "production") {
          // TODO [#1292]: Remove the readonly decorator
          if (arguments.length !== 1) {
              assert.fail("@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value.");
          }
      }
      return reactiveMembrane.getReadOnlyProxy(obj);
  }
  /*
   * Copyright (c) 2022, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ // flag indicating if the hydration recovered from the DOM mismatch
  var hasMismatch = false;
  function hydrateRoot(vm) {
      hasMismatch = false;
      runConnectedCallback(vm);
      hydrateVM(vm);
      if (hasMismatch) {
          logError("Hydration completed with errors.", vm);
      }
  }
  function hydrateVM(vm) {
      var children = renderComponent(vm);
      vm.children = children;
      var parentNode = vm.renderRoot;
      hydrateChildren(getFirstChild$1(parentNode), children, parentNode, vm);
      runRenderedCallback(vm);
  }
  function hydrateNode(node, vnode) {
      var hydratedNode;
      switch(vnode.type){
          case 0 /* Text */ :
              hydratedNode = hydrateText(node, vnode);
              break;
          case 1 /* Comment */ :
              hydratedNode = hydrateComment(node, vnode);
              break;
          case 2 /* Element */ :
              hydratedNode = hydrateElement(node, vnode);
              break;
          case 3 /* CustomElement */ :
              hydratedNode = hydrateCustomElement(node, vnode);
              break;
      }
      return nextSibling$1(hydratedNode);
  }
  function hydrateText(node, vnode) {
      var _a;
      if (!hasCorrectNodeType(vnode, node, 3 /* TEXT */ )) {
          return handleMismatch(node, vnode);
      }
      if (process.env.NODE_ENV !== "production") {
          var nodeValue = getProperty$1(node, "nodeValue");
          if (nodeValue !== vnode.text && !(nodeValue === "\u200D" && vnode.text === "")) {
              logWarn("Hydration mismatch: text values do not match, will recover from the difference", vnode.owner);
          }
      }
      setText$1(node, (_a = vnode.text) !== null && _a !== void 0 ? _a : null);
      vnode.elm = node;
      return node;
  }
  function hydrateComment(node, vnode) {
      var _a;
      if (!hasCorrectNodeType(vnode, node, 8 /* COMMENT */ )) {
          return handleMismatch(node, vnode);
      }
      if (process.env.NODE_ENV !== "production") {
          var nodeValue = getProperty$1(node, "nodeValue");
          if (nodeValue !== vnode.text) {
              logWarn("Hydration mismatch: comment values do not match, will recover from the difference", vnode.owner);
          }
      }
      setProperty$1(node, "nodeValue", (_a = vnode.text) !== null && _a !== void 0 ? _a : null);
      vnode.elm = node;
      return node;
  }
  function hydrateElement(elm, vnode) {
      if (!hasCorrectNodeType(vnode, elm, 1 /* ELEMENT */ ) || !isMatchingElement(vnode, elm)) {
          return handleMismatch(elm, vnode);
      }
      vnode.elm = elm;
      var context = vnode.data.context;
      var isDomManual = Boolean(!isUndefined$1(context) && !isUndefined$1(context.lwc) && context.lwc.dom === "manual" /* Manual */ );
      if (isDomManual) {
          // it may be that this element has lwc:inner-html, we need to diff and in case are the same,
          // remove the innerHTML from props so it reuses the existing dom elements.
          var props = vnode.data.props;
          if (!isUndefined$1(props) && !isUndefined$1(props.innerHTML)) {
              if (getProperty$1(elm, "innerHTML") === props.innerHTML) {
                  // Do a shallow clone since VNodeData may be shared across VNodes due to hoist optimization
                  vnode.data = Object.assign(Object.assign({}, vnode.data), {
                      props: cloneAndOmitKey(props, "innerHTML")
                  });
              } else {
                  if (process.env.NODE_ENV !== "production") {
                      logWarn("Mismatch hydrating element <".concat(getProperty$1(elm, "tagName").toLowerCase(), ">: innerHTML values do not match for element, will recover from the difference"), vnode.owner);
                  }
              }
          }
      }
      patchElementPropsAndAttrs(vnode);
      if (!isDomManual) {
          hydrateChildren(getFirstChild$1(elm), vnode.children, elm, vnode.owner);
      }
      return elm;
  }
  function hydrateCustomElement(elm, vnode) {
      if (!hasCorrectNodeType(vnode, elm, 1 /* ELEMENT */ ) || !isMatchingElement(vnode, elm)) {
          return handleMismatch(elm, vnode);
      }
      var sel = vnode.sel, mode = vnode.mode, ctor = vnode.ctor, owner = vnode.owner;
      var vm = createVM(elm, ctor, {
          mode: mode,
          owner: owner,
          tagName: sel
      });
      vnode.elm = elm;
      vnode.vm = vm;
      allocateChildren(vnode, vm);
      patchElementPropsAndAttrs(vnode);
      // Insert hook section:
      if (process.env.NODE_ENV !== "production") {
          assert.isTrue(vm.state === 0 /* created */ , "".concat(vm, " cannot be recycled."));
      }
      runConnectedCallback(vm);
      if (vm.renderMode !== 0 /* Light */ ) {
          // VM is not rendering in Light DOM, we can proceed and hydrate the slotted content.
          // Note: for Light DOM, this is handled while hydrating the VM
          hydrateChildren(getFirstChild$1(elm), vnode.children, elm, vm);
      }
      hydrateVM(vm);
      return elm;
  }
  function hydrateChildren(node, children, parentNode, owner) {
      var hasWarned = false;
      var nextNode = node;
      var anchor = null;
      for(var _$i25 = 0; _$i25 < children.length; _$i25++){
          var childVnode = children[_$i25];
          if (!isNull(childVnode)) {
              if (nextNode) {
                  nextNode = hydrateNode(nextNode, childVnode);
                  anchor = childVnode.elm;
              } else {
                  hasMismatch = true;
                  if (process.env.NODE_ENV !== "production") {
                      if (!hasWarned) {
                          hasWarned = true;
                          logError("Hydration mismatch: incorrect number of rendered nodes. Client produced more nodes than the server.", owner);
                      }
                  }
                  mount(childVnode, parentNode, anchor);
                  anchor = childVnode.elm;
              }
          }
      }
      if (nextNode) {
          hasMismatch = true;
          if (process.env.NODE_ENV !== "production") {
              if (!hasWarned) {
                  logError("Hydration mismatch: incorrect number of rendered nodes. Server rendered more nodes than the client.", owner);
              }
          }
          do {
              var current = nextNode;
              nextNode = nextSibling$1(nextNode);
              removeNode(current, parentNode);
          }while (nextNode);
      }
  }
  function handleMismatch(node, vnode, msg) {
      hasMismatch = true;
      if (!isUndefined$1(msg)) {
          if (process.env.NODE_ENV !== "production") {
              logError(msg, vnode.owner);
          }
      }
      var parentNode = getProperty$1(node, "parentNode");
      mount(vnode, parentNode, node);
      removeNode(node, parentNode);
      return vnode.elm;
  }
  function patchElementPropsAndAttrs(vnode) {
      applyEventListeners(vnode);
      patchProps(null, vnode);
  }
  function hasCorrectNodeType(vnode, node, nodeType) {
      if (getProperty$1(node, "nodeType") !== nodeType) {
          if (process.env.NODE_ENV !== "production") {
              logError("Hydration mismatch: incorrect node type received", vnode.owner);
          }
          return false;
      }
      return true;
  }
  function isMatchingElement(vnode, elm) {
      if (vnode.sel.toLowerCase() !== getProperty$1(elm, "tagName").toLowerCase()) {
          if (process.env.NODE_ENV !== "production") {
              logError('Hydration mismatch: expecting element with tag "'.concat(vnode.sel.toLowerCase(), '" but found "').concat(getProperty$1(elm, "tagName").toLowerCase(), '".'), vnode.owner);
          }
          return false;
      }
      var hasIncompatibleAttrs = validateAttrs(vnode, elm);
      var hasIncompatibleClass = validateClassAttr(vnode, elm);
      var hasIncompatibleStyle = validateStyleAttr(vnode, elm);
      return hasIncompatibleAttrs && hasIncompatibleClass && hasIncompatibleStyle;
  }
  function validateAttrs(vnode, elm) {
      var _data = vnode.data, _attrs = _data.attrs, attrs = _attrs === void 0 ? {} : _attrs;
      var nodesAreCompatible = true;
      var _iteratorNormalCompletion5 = true, _didIteratorError5 = false, _iteratorError5 = undefined;
      try {
          // Validate attributes, though we could always recovery from those by running the update mods.
          // Note: intentionally ONLY matching vnodes.attrs to elm.attrs, in case SSR is adding extra attributes.
          for(var _iterator = Object.entries(attrs)[Symbol.iterator](), _step; !(_iteratorNormalCompletion5 = (_step = _iterator.next()).done); _iteratorNormalCompletion5 = true){
              var _value = _slicedToArray(_step.value, 2), attrName = _value[0], attrValue = _value[1];
              var elmAttrValue = getAttribute$1(elm, attrName);
              if (String(attrValue) !== elmAttrValue) {
                  if (process.env.NODE_ENV !== "production") {
                      logError("Mismatch hydrating element <".concat(getProperty$1(elm, "tagName").toLowerCase(), '>: attribute "').concat(attrName, '" has different values, expected "').concat(attrValue, '" but found "').concat(elmAttrValue, '"'), vnode.owner);
                  }
                  nodesAreCompatible = false;
              }
          }
      } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
      } finally{
          try {
              if (!_iteratorNormalCompletion5 && _iterator.return != null) {
                  _iterator.return();
              }
          } finally{
              if (_didIteratorError5) {
                  throw _iteratorError5;
              }
          }
      }
      return nodesAreCompatible;
  }
  function validateClassAttr(vnode, elm) {
      var _data = vnode.data, className = _data.className, classMap = _data.classMap;
      var nodesAreCompatible = true;
      var vnodeClassName;
      if (!isUndefined$1(className) && String(className) !== getProperty$1(elm, "className")) {
          // className is used when class is bound to an expr.
          nodesAreCompatible = false;
          vnodeClassName = className;
      } else if (!isUndefined$1(classMap)) {
          // classMap is used when class is set to static value.
          var classList = getClassList$1(elm);
          var computedClassName = "";
          // all classes from the vnode should be in the element.classList
          for(var name in classMap){
              computedClassName += " " + name;
              if (!classList.contains(name)) {
                  nodesAreCompatible = false;
              }
          }
          vnodeClassName = computedClassName.trim();
          if (classList.length > keys(classMap).length) {
              nodesAreCompatible = false;
          }
      }
      if (!nodesAreCompatible) {
          if (process.env.NODE_ENV !== "production") {
              logError("Mismatch hydrating element <".concat(getProperty$1(elm, "tagName").toLowerCase(), '>: attribute "class" has different values, expected "').concat(vnodeClassName, '" but found "').concat(getProperty$1(elm, "className"), '"'), vnode.owner);
          }
      }
      return nodesAreCompatible;
  }
  function validateStyleAttr(vnode, elm) {
      var _data = vnode.data, style = _data.style, styleDecls = _data.styleDecls;
      var elmStyle = getAttribute$1(elm, "style") || "";
      var vnodeStyle;
      var nodesAreCompatible = true;
      if (!isUndefined$1(style) && style !== elmStyle) {
          nodesAreCompatible = false;
          vnodeStyle = style;
      } else if (!isUndefined$1(styleDecls)) {
          var parsedVnodeStyle = parseStyleText(elmStyle);
          var expectedStyle = [];
          // styleMap is used when style is set to static value.
          for(var _$i26 = 0, n = styleDecls.length; _$i26 < n; _$i26++){
              var _i = _slicedToArray(styleDecls[_$i26], 3), prop = _i[0], value = _i[1], important = _i[2];
              expectedStyle.push("".concat(prop, ": ").concat(value + (important ? " important!" : "")));
              var parsedPropValue = parsedVnodeStyle[prop];
              if (isUndefined$1(parsedPropValue)) {
                  nodesAreCompatible = false;
              } else if (!parsedPropValue.startsWith(value)) {
                  nodesAreCompatible = false;
              } else if (important && !parsedPropValue.endsWith("!important")) {
                  nodesAreCompatible = false;
              }
          }
          if (keys(parsedVnodeStyle).length > styleDecls.length) {
              nodesAreCompatible = false;
          }
          vnodeStyle = ArrayJoin.call(expectedStyle, ";");
      }
      if (!nodesAreCompatible) {
          if (process.env.NODE_ENV !== "production") {
              logError("Mismatch hydrating element <".concat(getProperty$1(elm, "tagName").toLowerCase(), '>: attribute "style" has different values, expected "').concat(vnodeStyle, '" but found "').concat(elmStyle, '".'), vnode.owner);
          }
      }
      return nodesAreCompatible;
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var hooksAreSet = false;
  function setHooks(hooks1) {
      assert.isFalse(hooksAreSet, "Hooks are already overridden, only one definition is allowed.");
      hooksAreSet = true;
      setSanitizeHtmlContentHook(hooks1.sanitizeHtmlContent);
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ /**
   * EXPERIMENTAL: This function provides access to the component constructor, given an HTMLElement.
   * This API is subject to change or being removed.
   */ function getComponentConstructor(elm) {
      var ctor = null;
      // intentionally checking for undefined due to some funky libraries patching weakmap.get
      // to throw when undefined.
      if (!isUndefined$1(elm)) {
          var vm = getAssociatedVMIfPresent(elm);
          if (!isUndefined$1(vm)) {
              ctor = vm.def.ctor;
          }
      }
      return ctor;
  }
  /* version: 2.13.3 */ /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var globalStylesheets = create(null);
  if (process.env.NODE_ENV === "development") {
      // @ts-ignore
      window.__lwcResetGlobalStylesheets = function() {
          var _iteratorNormalCompletion6 = true, _didIteratorError6 = false, _iteratorError6 = undefined;
          try {
              for(var _iterator = Object.keys(globalStylesheets)[Symbol.iterator](), _step; !(_iteratorNormalCompletion6 = (_step = _iterator.next()).done); _iteratorNormalCompletion6 = true){
                  var key = _step.value;
                  delete globalStylesheets[key];
              }
          } catch (err) {
              _didIteratorError6 = true;
              _iteratorError6 = err;
          } finally{
              try {
                  if (!_iteratorNormalCompletion6 && _iterator.return != null) {
                      _iterator.return();
                  }
              } finally{
                  if (_didIteratorError6) {
                      throw _iteratorError6;
                  }
              }
          }
      };
  }
  var globalStylesheetsParentElement = document.head || document.body || document;
  // This check for constructable stylesheets is similar to Fast's:
  // https://github.com/microsoft/fast/blob/d49d1ec/packages/web-components/fast-element/src/dom.ts#L51-L53
  // See also: https://github.com/whatwg/webidl/issues/1027#issuecomment-934510070
  var supportsConstructableStyleSheets = isFunction$1(CSSStyleSheet.prototype.replaceSync) && isArray$1(document.adoptedStyleSheets);
  var supportsMutableAdoptedStyleSheets = supportsConstructableStyleSheets && getOwnPropertyDescriptor$1(document.adoptedStyleSheets, "length").writable;
  var styleElements = create(null);
  var styleSheets = create(null);
  var shadowRootsToStyleSheets = new WeakMap();
  var getCustomElement;
  var defineCustomElement;
  var HTMLElementConstructor;
  function isCustomElementRegistryAvailable() {
      if (typeof customElements === "undefined") {
          return false;
      }
      try {
          // dereference HTMLElement global because babel wraps globals in compat mode with a
          // _wrapNativeSuper()
          // This is a problem because LWCUpgradableElement extends renderer.HTMLElement which does not
          // get wrapped by babel.
          var HTMLElementAlias1 = HTMLElement;
          // In case we use compat mode with a modern browser, the compat mode transformation
          // invokes the DOM api with an .apply() or .call() to initialize any DOM api sub-classing,
          // which are not equipped to be initialized that way.
          var clazz = /*#__PURE__*/ function(HTMLElementAlias) {
              "use strict";
              _inherits(clazz, HTMLElementAlias);
              var _super = _createSuper(clazz);
              function clazz() {
                  _classCallCheck(this, clazz);
                  return _super.apply(this, arguments);
              }
              return clazz;
          }(HTMLElementAlias1);
          customElements.define("lwc-test-" + Math.floor(Math.random() * 1000000), clazz);
          new clazz();
          return true;
      } catch (_a) {
          return false;
      }
  }
  function insertConstructableStyleSheet(content, target) {
      // It's important for CSSStyleSheets to be unique based on their content, so that
      // `shadowRoot.adoptedStyleSheets.includes(sheet)` works.
      var styleSheet = styleSheets[content];
      if (isUndefined$1(styleSheet)) {
          styleSheet = new CSSStyleSheet();
          styleSheet.replaceSync(content);
          styleSheets[content] = styleSheet;
      }
      var adoptedStyleSheets = target.adoptedStyleSheets;
      if (!adoptedStyleSheets.includes(styleSheet)) {
          if (supportsMutableAdoptedStyleSheets) {
              // This is only supported in later versions of Chromium:
              // https://chromestatus.com/feature/5638996492288000
              adoptedStyleSheets.push(styleSheet);
          } else {
              target.adoptedStyleSheets = _toConsumableArray(adoptedStyleSheets).concat([
                  styleSheet
              ]);
          }
      }
  }
  function insertStyleElement(content, target) {
      // Avoid inserting duplicate `<style>`s
      var sheets = shadowRootsToStyleSheets.get(target);
      if (isUndefined$1(sheets)) {
          sheets = create(null);
          shadowRootsToStyleSheets.set(target, sheets);
      }
      if (sheets[content]) {
          return;
      }
      sheets[content] = true;
      // This `<style>` may be repeated multiple times in the DOM, so cache it. It's a bit
      // faster to call `cloneNode()` on an existing node than to recreate it every time.
      var elm = styleElements[content];
      if (isUndefined$1(elm)) {
          elm = document.createElement("style");
          elm.type = "text/css";
          elm.textContent = content;
          styleElements[content] = elm;
      } else {
          elm = elm.cloneNode(true);
      }
      target.appendChild(elm);
  }
  if (isCustomElementRegistryAvailable()) {
      getCustomElement = customElements.get.bind(customElements);
      defineCustomElement = customElements.define.bind(customElements);
      HTMLElementConstructor = HTMLElement;
  } else {
      var registry = create(null);
      var reverseRegistry = new WeakMap();
      defineCustomElement = function define(name, ctor) {
          if (name !== StringToLowerCase.call(name) || registry[name]) {
              throw new TypeError("Invalid Registration");
          }
          registry[name] = ctor;
          reverseRegistry.set(ctor, name);
      };
      getCustomElement = function get(name) {
          return registry[name];
      };
      HTMLElementConstructor = function HTMLElement() {
          if (!_instanceof(this, HTMLElement)) {
              throw new TypeError("Invalid Invocation");
          }
          var constructor = this.constructor;
          var name = reverseRegistry.get(constructor);
          if (!name) {
              throw new TypeError("Invalid Construction");
          }
          var elm = document.createElement(name);
          setPrototypeOf(elm, constructor.prototype);
          return elm;
      };
      HTMLElementConstructor.prototype = HTMLElement.prototype;
  }
  var hydrating = false;
  function setIsHydrating(value) {
      hydrating = value;
  }
  var ssr = false;
  function isHydrating() {
      return hydrating;
  }
  var isNativeShadowDefined = _globalThis[KEY__IS_NATIVE_SHADOW_ROOT_DEFINED];
  var isSyntheticShadowDefined = hasOwnProperty$1.call(Element.prototype, KEY__SHADOW_TOKEN);
  function createElement$1(tagName, namespace) {
      return isUndefined$1(namespace) ? document.createElement(tagName) : document.createElementNS(namespace, tagName);
  }
  function createText(content) {
      return document.createTextNode(content);
  }
  function createComment(content) {
      return document.createComment(content);
  }
  function insert(node, parent, anchor) {
      parent.insertBefore(node, anchor);
  }
  function remove(node, parent) {
      parent.removeChild(node);
  }
  function nextSibling(node) {
      return node.nextSibling;
  }
  function attachShadow(element, options) {
      if (hydrating) {
          return element.shadowRoot;
      }
      return element.attachShadow(options);
  }
  function setText(node, content) {
      node.nodeValue = content;
  }
  function getProperty(node, key) {
      return node[key];
  }
  function setProperty(node, key, value) {
      if (process.env.NODE_ENV !== "production") {
          if (_instanceof(node, Element) && !(key in node)) {
              // TODO [#1297]: Move this validation to the compiler
              assert.fail('Unknown public property "'.concat(key, '" of element <').concat(node.tagName, '>. This is likely a typo on the corresponding attribute "').concat(htmlPropertyToAttribute(key), '".'));
          }
      }
      node[key] = value;
  }
  function getAttribute(element, name, namespace) {
      return isUndefined$1(namespace) ? element.getAttribute(name) : element.getAttributeNS(namespace, name);
  }
  function setAttribute(element, name, value, namespace) {
      return isUndefined$1(namespace) ? element.setAttribute(name, value) : element.setAttributeNS(namespace, name, value);
  }
  function removeAttribute(element, name, namespace) {
      if (isUndefined$1(namespace)) {
          element.removeAttribute(name);
      } else {
          element.removeAttributeNS(namespace, name);
      }
  }
  function addEventListener(target, type, callback, options) {
      target.addEventListener(type, callback, options);
  }
  function removeEventListener(target, type, callback, options) {
      target.removeEventListener(type, callback, options);
  }
  function dispatchEvent(target, event) {
      return target.dispatchEvent(event);
  }
  function getClassList(element) {
      return element.classList;
  }
  function setCSSStyleProperty(element, name, value, important) {
      // TODO [#0]: How to avoid this type casting? Shall we use a different type interface to
      // represent elements in the engine?
      element.style.setProperty(name, value, important ? "important" : "");
  }
  function getBoundingClientRect(element) {
      return element.getBoundingClientRect();
  }
  function querySelector(element, selectors) {
      return element.querySelector(selectors);
  }
  function querySelectorAll(element, selectors) {
      return element.querySelectorAll(selectors);
  }
  function getElementsByTagName(element, tagNameOrWildCard) {
      return element.getElementsByTagName(tagNameOrWildCard);
  }
  function getElementsByClassName(element, names) {
      return element.getElementsByClassName(names);
  }
  function getChildren(element) {
      return element.children;
  }
  function getChildNodes(element) {
      return element.childNodes;
  }
  function getFirstChild(element) {
      return element.firstChild;
  }
  function getFirstElementChild(element) {
      return element.firstElementChild;
  }
  function getLastChild(element) {
      return element.lastChild;
  }
  function getLastElementChild(element) {
      return element.lastElementChild;
  }
  function isConnected(node) {
      return node.isConnected;
  }
  function insertGlobalStylesheet(content) {
      if (!isUndefined$1(globalStylesheets[content])) {
          return;
      }
      globalStylesheets[content] = true;
      var elm = document.createElement("style");
      elm.type = "text/css";
      elm.textContent = content;
      globalStylesheetsParentElement.appendChild(elm);
  }
  function insertStylesheet(content, target) {
      if (supportsConstructableStyleSheets) {
          insertConstructableStyleSheet(content, target);
      } else {
          // Fall back to <style> element
          insertStyleElement(content, target);
      }
  }
  function assertInstanceOfHTMLElement(elm, msg) {
      assert.invariant(_instanceof(elm, HTMLElement), msg);
  }
  var HTMLElementExported = HTMLElementConstructor;
  /*
   * Copyright (c) 2020, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ setAssertInstanceOfHTMLElement(assertInstanceOfHTMLElement);
  setAttachShadow(attachShadow);
  setCreateComment(createComment);
  setCreateElement(createElement$1);
  setCreateText(createText);
  setDefineCustomElement(defineCustomElement);
  setDispatchEvent(dispatchEvent);
  setGetAttribute(getAttribute);
  setGetBoundingClientRect(getBoundingClientRect);
  setGetChildNodes(getChildNodes);
  setGetChildren(getChildren);
  setGetClassList(getClassList);
  setGetCustomElement(getCustomElement);
  setGetElementsByClassName(getElementsByClassName);
  setGetElementsByTagName(getElementsByTagName);
  setGetFirstChild(getFirstChild);
  setGetFirstElementChild(getFirstElementChild);
  setGetLastChild(getLastChild);
  setGetLastElementChild(getLastElementChild);
  setGetProperty(getProperty);
  setHTMLElement(HTMLElementExported);
  setInsert(insert);
  setInsertGlobalStylesheet(insertGlobalStylesheet);
  setInsertStylesheet(insertStylesheet);
  setIsConnected(isConnected);
  setIsHydrating$1(isHydrating);
  setIsNativeShadowDefined(isNativeShadowDefined);
  setIsSyntheticShadowDefined(isSyntheticShadowDefined);
  setNextSibling(nextSibling);
  setQuerySelector(querySelector);
  setQuerySelectorAll(querySelectorAll);
  setRemove(remove);
  setRemoveAttribute(removeAttribute);
  setRemoveEventListener(removeEventListener);
  setSetAttribute(setAttribute);
  setSetCSSStyleProperty(setCSSStyleProperty);
  setSetProperty(setProperty);
  setSetText(setText);
  setSsr(ssr);
  setAddEventListener(addEventListener);
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ function resetShadowRootAndLightDom(element, Ctor) {
      if (element.shadowRoot) {
          var shadowRoot = element.shadowRoot;
          while(!isNull(shadowRoot.firstChild)){
              shadowRoot.removeChild(shadowRoot.firstChild);
          }
      }
      if (Ctor.renderMode === "light") {
          while(!isNull(element.firstChild)){
              element.removeChild(element.firstChild);
          }
      }
  }
  function createVMWithProps(element, Ctor, props) {
      var vm = createVM(element, Ctor, {
          mode: "open",
          owner: null,
          tagName: element.tagName.toLowerCase()
      });
      var _iteratorNormalCompletion7 = true, _didIteratorError7 = false, _iteratorError7 = undefined;
      try {
          for(var _iterator = Object.entries(props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion7 = (_step = _iterator.next()).done); _iteratorNormalCompletion7 = true){
              var _value = _slicedToArray(_step.value, 2), key = _value[0], value = _value[1];
              element[key] = value;
          }
      } catch (err) {
          _didIteratorError7 = true;
          _iteratorError7 = err;
      } finally{
          try {
              if (!_iteratorNormalCompletion7 && _iterator.return != null) {
                  _iterator.return();
              }
          } finally{
              if (_didIteratorError7) {
                  throw _iteratorError7;
              }
          }
      }
      return vm;
  }
  function hydrateComponent(element, Ctor) {
      var props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (!_instanceof(element, Element)) {
          throw new TypeError('"hydrateComponent" expects a valid DOM element as the first parameter but instead received '.concat(element, "."));
      }
      if (!isFunction$1(Ctor)) {
          throw new TypeError('"hydrateComponent" expects a valid component constructor as the second parameter but instead received '.concat(Ctor, "."));
      }
      if (!isObject(props) || isNull(props)) {
          throw new TypeError('"hydrateComponent" expects an object as the third parameter but instead received '.concat(props, "."));
      }
      if (getAssociatedVMIfPresent(element)) {
          /* eslint-disable-next-line no-console */ console.warn('"hydrateComponent" expects an element that is not hydrated.', element);
          return;
      }
      try {
          // Let the renderer know we are hydrating, so it does not replace the existing shadowRoot
          // and uses the same algo to create the stylesheets as in SSR.
          setIsHydrating(true);
          var vm = createVMWithProps(element, Ctor, props);
          hydrateRoot(vm);
          // set it back since now we finished hydration.
          setIsHydrating(false);
      } catch (e) {
          // Fallback: In case there's an error while hydrating, let's log the error, and replace the element content
          //           with the client generated DOM.
          /* eslint-disable-next-line no-console */ console.error("Recovering from error while hydrating: ", e);
          // We want to preserve the element, so we need to reset the shadowRoot and light dom.
          resetShadowRootAndLightDom(element, Ctor);
          // we need to recreate the vm with the hydration flag on, so it re-uses the existing shadowRoot.
          createVMWithProps(element, Ctor, props);
          setIsHydrating(false);
          connectRootElement(element);
      } finally{
          // in case there's an error during recovery
          setIsHydrating(false);
      }
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ /**
   * This function builds a Web Component class from a LWC constructor so it can be
   * registered as a new element via customElements.define() at any given time.
   *
   * @deprecated since version 1.3.11
   *
   * @example
   * ```
   * import { buildCustomElementConstructor } from 'lwc';
   * import Foo from 'ns/foo';
   * const WC = buildCustomElementConstructor(Foo);
   * customElements.define('x-foo', WC);
   * const elm = document.createElement('x-foo');
   * ```
   */ function deprecatedBuildCustomElementConstructor(Ctor) {
      if (process.env.NODE_ENV !== "production") {
          /* eslint-disable-next-line no-console */ console.warn('Deprecated function called: "buildCustomElementConstructor" function is deprecated and it will be removed.' + 'Use "'.concat(Ctor.name, '.CustomElementConstructor" static property of the component constructor to access the corresponding custom element constructor instead.'));
      }
      return Ctor.CustomElementConstructor;
  }
  // Note: WeakSet is not supported in IE11, and the polyfill is not performant enough.
  //       This WeakSet usage is valid because this functionality is not meant to run in IE11.
  var hydratedCustomElements = new WeakSet();
  function buildCustomElementConstructor(Ctor) {
      var HtmlPrototype1 = getComponentHtmlPrototype(Ctor);
      return /*#__PURE__*/ function(HtmlPrototype) {
          _inherits(_class, HtmlPrototype);
          var _super = _createSuper(_class);
          function _class() {
              _classCallCheck(this, _class);
              var _this;
              _this = _super.call(this);
              if (_this.isConnected) {
                  // this if block is hit when there's already an un-upgraded element in the DOM with the same tag name.
                  hydrateComponent(_assertThisInitialized(_this), Ctor, {});
                  hydratedCustomElements.add(_assertThisInitialized(_this));
              } else {
                  createVM(_assertThisInitialized(_this), Ctor, {
                      mode: "open",
                      owner: null,
                      tagName: _this.tagName
                  });
              }
              return _this;
          }
          _createClass(_class, [
              {
                  key: "connectedCallback",
                  value: function connectedCallback() {
                      if (hydratedCustomElements.has(this)) {
                          // This is an un-upgraded element that was hydrated in the constructor.
                          hydratedCustomElements.delete(this);
                      } else {
                          connectRootElement(this);
                      }
                  }
              },
              {
                  key: "disconnectedCallback",
                  value: function disconnectedCallback() {
                      disconnectRootElement(this);
                  }
              }
          ]);
          return _class;
      }(HtmlPrototype1);
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ // TODO [#2472]: Remove this workaround when appropriate.
  // eslint-disable-next-line lwc-internal/no-global-node
  var _Node$1 = Node;
  var ConnectingSlot = new WeakMap();
  var DisconnectingSlot = new WeakMap();
  function callNodeSlot(node, slot) {
      if (process.env.NODE_ENV !== "production") {
          assert.isTrue(node, "callNodeSlot() should not be called for a non-object");
      }
      var fn = slot.get(node);
      if (!isUndefined$1(fn)) {
          fn(node);
      }
      return node; // for convenience
  }
  // Monkey patching Node methods to be able to detect the insertions and removal of root elements
  // created via createElement.
  var _prototype3 = _Node$1.prototype, appendChild = _prototype3.appendChild, insertBefore = _prototype3.insertBefore, removeChild = _prototype3.removeChild, replaceChild = _prototype3.replaceChild;
  assign(_Node$1.prototype, {
      appendChild: function appendChild2(newChild) {
          var appendedNode = appendChild.call(this, newChild);
          return callNodeSlot(appendedNode, ConnectingSlot);
      },
      insertBefore: function insertBefore2(newChild, referenceNode) {
          var insertedNode = insertBefore.call(this, newChild, referenceNode);
          return callNodeSlot(insertedNode, ConnectingSlot);
      },
      removeChild: function removeChild2(oldChild) {
          var removedNode = removeChild.call(this, oldChild);
          return callNodeSlot(removedNode, DisconnectingSlot);
      },
      replaceChild: function replaceChild2(newChild, oldChild) {
          var replacedNode = replaceChild.call(this, newChild, oldChild);
          callNodeSlot(replacedNode, DisconnectingSlot);
          callNodeSlot(newChild, ConnectingSlot);
          return replacedNode;
      }
  });
  /**
   * EXPERIMENTAL: This function is almost identical to document.createElement with the slightly
   * difference that in the options, you can pass the `is` property set to a Constructor instead of
   * just a string value. The intent is to allow the creation of an element controlled by LWC without
   * having to register the element as a custom element.
   *
   * @example
   * ```
   * const el = createElement('x-foo', { is: FooCtor });
   * ```
   */ function createElement(sel, options) {
      if (!isObject(options) || isNull(options)) {
          throw new TypeError('"createElement" function expects an object as second parameter but received "'.concat(toString$1(options), '".'));
      }
      var Ctor = options.is;
      if (!isFunction$1(Ctor)) {
          throw new TypeError('"createElement" function expects an "is" option with a valid component constructor.');
      }
      var UpgradableConstructor = getUpgradableConstructor(sel);
      var wasComponentUpgraded = false;
      // the custom element from the registry is expecting an upgrade callback
      /**
       * Note: if the upgradable constructor does not expect, or throw when we new it
       * with a callback as the first argument, we could implement a more advanced
       * mechanism that only passes that argument if the constructor is known to be
       * an upgradable custom element.
       */ var element = new UpgradableConstructor(function(elm) {
          createVM(elm, Ctor, {
              tagName: sel,
              mode: options.mode !== "closed" ? "open" : "closed",
              owner: null
          });
          ConnectingSlot.set(elm, connectRootElement);
          DisconnectingSlot.set(elm, disconnectRootElement);
          wasComponentUpgraded = true;
      });
      if (!wasComponentUpgraded) {
          /* eslint-disable-next-line no-console */ console.error('Unexpected tag name "'.concat(sel, '". This name is a registered custom element, preventing LWC to upgrade the element.'));
      }
      return element;
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ // TODO [#2472]: Remove this workaround when appropriate.
  // eslint-disable-next-line lwc-internal/no-global-node
  var _Node = Node;
  /**
   * EXPERIMENTAL: The purpose of this function is to detect shadowed nodes. THIS API WILL BE REMOVED
   * ONCE LOCKER V1 IS NO LONGER SUPPORTED.
   */ function isNodeShadowed(node) {
      if (isFalse(_instanceof(node, _Node))) {
          return false;
      }
      // It's debatable whether shadow root instances should be considered as shadowed, but we keep
      // this unchanged for legacy reasons (#1250).
      if (_instanceof(node, ShadowRoot)) {
          return false;
      }
      var rootNode = node.getRootNode();
      // Handle the native case. We can return early here because an invariant of LWC is that
      // synthetic roots cannot be descendants of native roots.
      if (_instanceof(rootNode, ShadowRoot) && isFalse(hasOwnProperty$1.call(getPrototypeOf$1(rootNode), "synthetic"))) {
          return true;
      }
      // TODO [#1252]: Old behavior that is still used by some pieces of the platform. Manually
      // inserted nodes without the `lwc:dom=manual` directive will be considered as global elements.
      return isSyntheticShadowDefined && !isUndefined$1(node[KEY__SHADOW_RESOLVER]);
  }
  /*
   * Copyright (c) 2018, salesforce.com, inc.
   * All rights reserved.
   * SPDX-License-Identifier: MIT
   * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
   */ var ComponentConstructorToCustomElementConstructorMap = new Map();
  function getCustomElementConstructor(Ctor) {
      if (Ctor === LightningElement) {
          throw new TypeError("Invalid Constructor. LightningElement base class can't be claimed as a custom element.");
      }
      var ce = ComponentConstructorToCustomElementConstructorMap.get(Ctor);
      if (isUndefined$1(ce)) {
          ce = buildCustomElementConstructor(Ctor);
          ComponentConstructorToCustomElementConstructorMap.set(Ctor, ce);
      }
      return ce;
  }
  /**
   * This static getter builds a Web Component class from a LWC constructor so it can be registered
   * as a new element via customElements.define() at any given time. E.g.:
   *
   *      import Foo from 'ns/foo';
   *      customElements.define('x-foo', Foo.CustomElementConstructor);
   *      const elm = document.createElement('x-foo');
   *
   */ defineProperty(LightningElement, "CustomElementConstructor", {
      get: function get1() {
          return getCustomElementConstructor(this);
      }
  });
  freeze(LightningElement);
  seal(LightningElement.prototype);

  exports.LightningElement = LightningElement;
  exports.__unstable__ProfilerControl = profilerControl;
  exports.api = api$1;
  exports.buildCustomElementConstructor = deprecatedBuildCustomElementConstructor;
  exports.createContextProvider = createContextProvider;
  exports.createElement = createElement;
  exports.getComponentConstructor = getComponentConstructor;
  exports.getComponentDef = getComponentDef;
  exports.hydrateComponent = hydrateComponent;
  exports.isComponentConstructor = isComponentConstructor;
  exports.isNodeFromTemplate = isNodeShadowed;
  exports.readonly = readonly;
  exports.register = register;
  exports.registerComponent = registerComponent;
  exports.registerDecorators = registerDecorators;
  exports.registerTemplate = registerTemplate;
  exports.sanitizeAttribute = sanitizeAttribute;
  exports.setFeatureFlag = setFeatureFlag;
  exports.setFeatureFlagForTest = setFeatureFlagForTest;
  exports.setHooks = setHooks;
  exports.swapComponent = swapComponent;
  exports.swapStyle = swapStyle;
  exports.swapTemplate = swapTemplate;
  exports.track = track;
  exports.unwrap = unwrap;
  exports.wire = wire;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
